## 279. Perfect Squares

### Description

```
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

### Best Solution - DP

OPT(i) = min k=1,2,3...&&k^2<=i {OPT(i-k^2)+OPT(k^2)}

Have to init opt[0] and opt[k^2].

```
class Solution {
    public int numSquares(int n) {
        int[] opt = new int[n+1];
        opt[0] = 0;
        // init opt when it comes to square numbers, the number used is just 1
        for(int k=1; k*k<=n; k++)    opt[k*k] = 1;
        for(int i=1; i<=n; i++){
            int min = Integer.MAX_VALUE;
            for(int k=1; k*k<=i; k++){
                int tmp = opt[i-k*k]+opt[k*k];
                if(tmp<min) min=tmp;
            }
            opt[i] = min;
        }
        return opt[n];
    }
}
```

## 72. Edit Distance

### Description

```
Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

### Solution

ignore x, y == delete x, y

delete x == insert y

replace x with y == replace y with x

So insert, delete and replace can be replace by ignoring x(-), ignoring y(|) and replacing(/).


`opt(i, j)` is the minimum cost spent when changing string x1...xi to y1...yj(0 is left for empty string)

if i=0, diff(empty, y1...yj): j
if j=0, diff(x1...xi, empty): i

```
opt(i, j) = min(
                opt(i-1, j-1)+0(xi==yj)/1(xi!=yj)
                opt(i-1, j)+1
                opt(i, j-1)+1
            )
```

```
class Solution {
    public int minDistance(String word1, String word2) {
        if(word1.length()==0) return word2.length();
        if(word2.length()==0) return word1.length();
        int[][] opt = new int[word1.length()+1][word2.length()+1];
        for(int i=0; i<opt.length; i++) opt[i][0] = i;
        for(int j=0; j<opt[0].length; j++) opt[0][j] = j;
        for(int i=1; i<opt.length; i++){
            for(int j=1; j<opt[0].length; j++){
                opt[i][j] = min(opt[i-1][j-1]+(word1.charAt(i-1)==word2.charAt(j-1)?0:1), opt[i-1][j]+1, opt[i][j-1]+1);
            }
        }
        return opt[opt.length-1][opt[0].length-1];
    }
    private int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
}
```

## 5. Longest Palindromic Substring

### Description

```
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
```

### Solution - DP

`opt(i, j)` is boolean, whether `s.substring(i, j+1)` is palindrome or not. Both i and j are inclusive

Length 1 word `(i, i)` and length 2 word `(i, i+1)` are set by for loop.

Then the length grows from `opt[i+1][i+x-1]` to `opt[i][i+x]`, which grows by 2. For example, from length 1 to 3, to 5, etc. And length 2 to 4, to 6, etc. Then I grow word's length from 1, 2 to 3,4,5,etc.

Finally just check the max of `j-i+1` where `opt(i, j)` is `true`.

Note that due to dependency of `opt[i+1][i+x-1]` to calculate `opt[i][i+x]`, I have to calculate crossly to final one slot.

Calculate in the following order.

1. (0, 2), (1, 3), (2, 4) // +2
2. (0, 3), (1, 4) // +3
3. (0, 4) //+4

```
| j\i | 0 | 1 | 2 | 3 | 4 |
|-----|---|---|---|---|---|
| 0   | T |   |   |   |   |
| 1   | F | T |   |   |   |
| 2   |   | F | T |   |   |
| 3   |   |   | F | T |   |
| 4   |   |   |   | F | T |
```

```
class Solution {
    public String longestPalindrome(String s) {
        int length = s.length();
        if(length==0) return "";
        boolean[][] opt = new boolean[length][length];
        for(int i=0; i<length; i++) opt[i][i] = true;
        for(int i=0; i+1<length; i++) opt[i][i+1] = (s.charAt(i)==s.charAt(i+1));
        for(int x=2; x<length; x++){
            for(int i=0; i+x<length; i++){
                opt[i][i+x] = (opt[i+1][i+x-1] && (s.charAt(i)==s.charAt(i+x)));
            }
        }
        int max = 0;
        int start = -1;
        int end = -1;
        for(int i=0; i<length; i++){
            for(int j=i; j<length; j++){
                if(opt[i][j] && j-i+1>max){
                    max = j-i+1;
                    start = i;
                    end = j;
                }
            }
        }
        return s.substring(start, end+1);
        
    }
}
```

Time: O(n^2). (n-2)^2/2 = O(n^2). Nearly half of the square.
Space: O(n^2).


### Final Solution - Recursion

Grow from one letter, grow if `s[i-1]==s[j+1]`, grow() return length, start and end index. Then grow from 2 letters if they are the same. This will cover 1,3,5 and 2,4,6 so covers every number. Finally compare the length and return the string of max length.

```
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()==0) return "";
        int max = 0;
        int start = -1;
        int end = -1;
        for(int i=0; i<s.length(); i++){
            Position res = grow(i, i, s);
            if(res.length>max){
                max = res.length;
                start = res.start;
                end = res.end;
            }
        }
        for(int i=0; i+1<s.length(); i++){
            if(s.charAt(i)!=s.charAt(i+1)) continue;
            Position res = grow(i, i+1, s);
            if(res.length>max){
                max = res.length;
                start = res.start;
                end = res.end;
            }
        }
        return s.substring(start, end+1);
    }
    // start, end are inclusive
    private Position grow(int start, int end, String s){
        if(start-1>=0&&end+1<s.length()&&s.charAt(start-1)==s.charAt(end+1)) return grow(start-1, end+1, s);
        return new Position(end-start+1, start, end);
    }
}
class Position{
    int length;
    int start;
    int end;
    public Position(int length, int start, int end){
        this.length = length;
        this.start = start;
        this.end = end;
    }
}
```

Time: O(n^2)
Space: O(1)

## 338. Counting Bits

### Description

```
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

Example 1:

Input: 2
Output: [0,1,1]
Example 2:

Input: 5
Output: [0,1,1,2,1,2]
Follow up:

It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
Space complexity should be O(n).
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
```


### Solution Naive

```
class Solution {
    public int[] countBits(int num) {
        int[] ans = new int[num+1];
        for(int i=0; i<=num; i++){
            ans[i] = numOfOnes(i);
        }
        return ans;
    }
    private int numOfOnes(int num){
        int count = 0;
        while(num>0){
            count+=(num&1);
            num = num>>>1;
        }
        return count;
    }
}
```

Time: O(n*logn). Since logn is the number of bits(size) for n.
Space: O(n)

### Final Solution - DP

opt(i) = last digit(1/0) + opt(i remove last digit). Since after removing last digit it's smaller than i, then that opt already exist, this saves time by reusing previous result.

```
class Solution {
    public int[] countBits(int num) {
        int[] opt = new int[num+1];
        for(int i=0; i<=num; i++) opt[i] = (i&1) + opt[i>>>1]; // have to use () for i&1 otherwise + will be executed first
        return opt;
    }
}
```

Time: O(n)
Space: O(n)

## 32. Longest Valid Parentheses

### Description

```
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

### Solution - Brute Force(TLE)

```
class Solution {
    public int longestValidParentheses(String s) {
        int max = 0;
        // i, j inclusive
        for(int i=0; i<s.length(); i++){
            for(int j=i+1; j<s.length(); j++){
                if(valid(s, i, j)) max = Math.max(max, j-i+1);
            }
        }
        return max;
    }
   // start, end inclusive
    private boolean valid(String s, int start, int end){
        int l = 0;
        int r = 0;
        for(int i=start; i<=end; i++){
            if(s.charAt(i)=='('){
                if(r>0) return false;
                else    l++;
            }else if(s.charAt(i)==')'){
                if(l>0) l--;
                else    return false;
            }
        }
        return l==0 && r==0;
    }
}
```

Time: O(n^3)

Space: O(1)

### Solution DP

If s[i-1]=='(':              opt[i] = 2+opt[i-2]; // may-be-valid()
If s[i-1-opt[i-1]]=='(':     opt[i] = 2+opt[i-1]+opt[i-1-opt[i-1]-1];// may-be-valid(valid-inside)

```
class Solution {
    public int longestValidParentheses(String s) {
        if(s.length()==0||s.length()==1) return 0;
        int[] opt = new int[s.length()];
        opt[0]=0;
        if(s.charAt(1)=='('){
            opt[1] = 0;
        }else{ // )
            if(s.charAt(0)=='(')    opt[1] = 2; //()
            else                    opt[1] = 0; //))
        }
        for(int i=2; i<s.length(); i++){
            if(s.charAt(i)=='('){
                opt[i] = 0;
            }else{ // )
                if(s.charAt(i-1)=='('){ // may-be-valid()
                    opt[i] = 2+opt[i-2];
                }else{ // ))
                    if(i-1-opt[i-1]>=0 && s.charAt(i-1-opt[i-1])=='('){ // may-be-valid(valid-inside)
                        if(i-1-opt[i-1]-1>=0)   opt[i] = 2+opt[i-1]+opt[i-1-opt[i-1]-1];
                        else                    opt[i] = 2+opt[i-1];
                    }else{ // )) or valid-inside))
                        opt[i] = 0;
                    }
                }
            }
        }
        int max = 0;
        for(int i=0; i<opt.length; i++){
            max = Math.max(max, opt[i]);
        }
        return max;
    }
}
```

Time: O(n)
Space: O(n)

### Final Solution - l==r

Walk throught string with one index. Only increment l and r, once invalid(r>l) reset l and r. Then walk through from length-1 to 0. l==r shows it's a valid substring, compare l+r with max.

```
class Solution {
    public int longestValidParentheses(String s) {
        int l = 0;
        int r = 0;
        int max = 0;
        for(int i=0; i<s.length(); i++){
            if(s.charAt(i)=='('){
                l++;
            }else{
                r++;
                if(r>l){
                    l = 0; r = 0;
                }
            }
            if(l==r) max = Math.max(max, l+r);
        }
        l = 0; r = 0;
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)=='('){
                l++;
                if(l>r){
                    l = 0; r = 0;
                }
            }else{
                r++;
            }
            if(l==r) max = Math.max(max, l+r);
        }
        return max;
    }
}
```


## 10. Regular Expression Matching

### Description

```
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
Example 4:

Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
Example 5:

Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
```

### Solution DP(Recursion+Memorization)

Be careful I have many choices for one case, for example, a* can match 0 which is "", or match "a" or match "aaa...". And the differnt matching of a* will influence next matching, for example, the matching of b* following it.

Why Backtracking? some path not call and try because not meet condition.

If i, j exceed limit: true(i, j finish successfully)
If j exceed i not: false(nothing to match anymore, but i not finish, so false)
If j not i finish: maybe it's multiple x* and can be treated as 0 match, so continue.
firstMatch: the same or j is .
If j+1 is *:
 1. match 0 time: i the same, j+2(skip char and *)
 2. match 1 or more time(only if firstMatch): i+1(next char), j the same
If j+1 isnot *:
 only if firstMatch, both go to next one(i+1, j+1) (if j+1 is * and firstMatch, for example a and a*, then I can use match 1 and match 0 to solve it, so I have to skip it here, otherwise will be duplicate computation, even it's dp and the earlier one have the true computation, I don't even want to call dup)

memo[i][j] uses `s.length()+1` since i may exceed, and since i+1 it will at most exceed one, uses `p.length()` since as long as j exceeds, it returns and not call memo using j.

Since i may exceed, but still valid when nextIsStar and match 0, so have to check i limitation before calling it with memo.

I used `int[][]` instead of `boolean[][]` because I need the default to know if it's has already been calculated or not.

The bottom up dp is very similiar, just calc memo[i][j] for each grid.

```
class Solution {
    int[][] memo; // 0 is default, 1 is true, -1 is false
    public boolean isMatch(String s, String p) {
        memo = new int[s.length()+1][p.length()];
        return isMatch(s, 0, p, 0);
    }
    private boolean isMatch(String s, int i, String p, int j){
        if(j>=p.length() && i>=s.length()) return true;
        if(j>=p.length() && i<s.length()) return false;
        if(memo[i][j]!=0) return memo[i][j]==1?true:false;
        boolean firstMatch = i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='.');
        boolean nextIsStar = j+1<p.length() && p.charAt(j+1)=='*';
        boolean ans = false;
        if(nextIsStar){ // x*, x can be . or any char
            ans = isMatch(s, i, p, j+2); // * match 0 of p[j]
            ans = ans || (firstMatch && isMatch(s, i+1, p, j)); // * match 1 or more of p[j]
        }else{ // point to same char or p[j] is ., then p[j] matches s[i]
            ans = firstMatch && isMatch(s, i+1, p, j+1);
        }
        memo[i][j] = ans==true?1:-1;
        return ans;
    }
}
```

m is s.length(), n is p.length().

Time: O(m*n), calculate each grid in memo[i][j] once, each takes O(1) time to calc.
Space: I(m*n)

## 44. Wildcard Matching

### Description

```
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "*"
Output: true
Explanation: '*' matches any sequence.
Example 3:

Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
Example 4:

Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
Example 5:

Input:
s = "acdcb"
p = "a*c?b"
Output: false
```

### Final Solution DP (Recursion+Memorization)

Similiar to 10.Regular Expression Matching.

If j is *, try match 0(j+1) and match 1 or more(i+1)
Otherwise check if first match, yes then try next pari(i+1, j+1)

Use int[][] memo to memory duplicate computation.

```
class Solution {
    private int[][] memo; // 0 is default, 1 is true, -1 is default
    public boolean isMatch(String s, String p) {
        // p exceed will return without calling memo, i exceed will call memo with i
        memo = new int[s.length()+1][p.length()];
        return isMatch(s, 0, p, 0);
    }
    private boolean isMatch(String s, int i, String p, int j){
        if(i>=s.length() && j>=p.length()) return true;
        if(i<s.length() && j>=p.length()) return false;
        if(memo[i][j]!=0) return memo[i][j]==1?true:false;
        boolean firstMatch = i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='?');
        boolean isStar = p.charAt(j)=='*';
        boolean ans = false;
        if(isStar){
            ans = isMatch(s, i, p, j+1); // match 0
            // match 1 or more, i have to be within limit so that can be matched by *
            ans = ans || (i<s.length() && isMatch(s, i+1, p, j));
        }else{
            ans = firstMatch && isMatch(s, i+1, p, j+1);
        }
        memo[i][j] = ans==true?1:-1;
        return ans;
    }
}
```

m is s.length(), n is p.length()

Time: O(m*n)
Space: I(m*n)

### Solution (KMP)

First time meet *, match 0 time. If encounter firstMatch is false, i and j go back to previous *, match time inc by 1. If all remaining j is *, then return true.

```
class Solution {
    public boolean isMatch(String s, String p) {
        int i=0, j=0, preStarIndexOfI=-1, preStarIndexOfJ=-1, matchNum=-1;
        while(i<s.length() && j<p.length()+1){ // j can exceed so that j can go back to use last * which is in len-1
            boolean firstMatch = j<p.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='?');
            boolean isStar = j<p.length() && (p.charAt(j)=='*');
            if(isStar){
                preStarIndexOfI = i;
                preStarIndexOfJ = j;
                matchNum = 0;
                j++; // match 0 time
            }else{
                if(firstMatch){
                    i++; j++;
                }else{
                    if(preStarIndexOfJ==-1) return false;
                    j = preStarIndexOfJ;
                    i = preStarIndexOfI;
                    matchNum++;
                    i += matchNum;
                    j++;
                }
            }
        }
        if(i>=s.length()){
            while(j<p.length()){
                if(p.charAt(j)!='*') return false;
                j++;
            }
            return true;
        }else{ // j>=p.length()+1
            return false;
        }
        
    }
}
```

## 62. Unique Paths

### Description

```
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
```

### Final Solution DP

opt(i, j) is the number of ways to reach bottom right corner(m-1, n-1) from position (i, j).

```
(i, j)      (i+1, j)
(i, j+1)
```

```
opt(i, j) = opt(i+1, j)(if i+1 exist) + opt(i, j+1)(if j+1 exist)
```

Why use i+1 and j+1 exist condition?

The position of i+j may be in boundary, for example, i=m-1, j=1, then they only have bottom no right.

`opt[m-1][n-1]` is 1 because `opt[m-2][n-2]` is definitly 2 ways, from right and from bottom, and it equals `opt[m-1][n-2]+opt[m-2][n-1]`, each should be one. And `opt[m-1][n-2]` equals `opt[m-1][n-1]` since it has no right way to bottom right corner. So `opt[m-1][n-1]` is 1.

```
(m-2, n-2)  (m-1, n-2)
(m-2, n-1)  (m-1, n-1) 
```

```
class Solution {
    public int uniquePaths(int m, int n) {
        if(m==0 || n==0) return 0;
        int[][] opt = new int[m][n];
        opt[m-1][n-1] = 1;
        for(int i=m-1; i>=0; i--){
            for(int j=n-1; j>=0; j--){
                if(i+1<m) opt[i][j] += opt[i+1][j];
                if(j+1<n) opt[i][j] += opt[i][j+1];
            }
        }
        return opt[0][0];
    }
}
```

## 63. Unique Paths II

### Description

```
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?



An obstacle and empty space is marked as 1 and 0 respectively in the grid.

Note: m and n will be at most 100.

Example 1:

Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right

```

### Final Solution - DP

opt(i, j) is the number of ways to reach bottom right corner(m-1, n-1) from position (i, j).

```
(i, j)      (i+1, j)
(i, j+1)
```

```
opt(i, j) = opt(i+1, j)(if i+1 exist and obstacle[i][j] is 0) + opt(i, j+1)(if j+1 exist and obstacle[i][j] is 0)
```

```
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int[][] opt = new int[obstacleGrid.length][obstacleGrid[0].length];
        if(obstacleGrid[opt.length-1][opt[0].length-1]==1) return 0; // if finish is obstacle, there is no way to be there
        opt[opt.length-1][opt[0].length-1] = 1;
        for(int i=opt.length-1; i>=0; i--){
            for(int j=opt[0].length-1; j>=0; j--){
                if(obstacleGrid[i][j]==0){ // if it's obstacle, no need to compute number of ways
                    if(i+1<opt.length && obstacleGrid[i+1][j]==0) opt[i][j] += opt[i+1][j];
                    if(j+1<opt[0].length && obstacleGrid[i][j+1]==0) opt[i][j] += opt[i][j+1];    
                }
            }
        }
        return opt[0][0];
    }
}
```

## 64. Minimum Path Sum

### Description

```
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.

```

### Final Solution - DP

opt(i, j) is the minimum path sum from (i, j) to (m-1, n-1).

```
(i, j)      (i, j+1)
(i+1, j)    (i+1, j+1)
```

```
opt(i, j) = grid(i, j) + min{opt(i+1, j)(if i+1 exist), opt(i, j+1)(if j+1 exist)}
```

opt(m-1, n-1) = grid(m-1, n-1).

return opt(0, 0).

```
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] opt = new int[m][n];
        for(int i=m-1; i>=0; i--){
            for(int j=n-1; j>=0; j--){
                opt[i][j] = grid[i][j];
                int min = -1;
                if(j+1<n) min = opt[i][j+1];
                if(i+1<m) min = (min==-1 ? opt[i+1][j] : Math.min(min, opt[i+1][j]));
                if(min!=-1) opt[i][j]+=min;
            }
        }
        return opt[0][0];
    }
}
```


## 85. Maximal Rectangle

### Description

### DP Solution - Memory Limit Exceeded

```
class Solution {
    private int[][][][] memo; // default to be -1, valid values: 0,1,2...
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0 || matrix[0].length==0) return 0;
        int rowLen = matrix.length;
        int colLen = matrix[0].length;
        // System.out.println("rowLen: "+ rowLen+", colLen: "+ colLen);
        memo = new int[rowLen][colLen][rowLen][colLen];
        initMemo();
        return maxRec(matrix, rowLen, colLen);
    }
    private int maxRec(char[][] matrix, int rowLen, int colLen){
        int max = 0;
        for(int i=0; i<rowLen; i++){
            for(int j=0; j<colLen; j++){
                for(int m=0; m<rowLen; m++){
                    for(int n=0; n<colLen; n++){
                        max = Math.max(max, opt(matrix, i, j, m, n));         
                    }
                }
            }
        }
        return max;
    }
    private void initMemo(){
        for(int i=0; i<memo.length; i++){
            for(int j=0; j<memo[0].length; j++){
                for(int m=0; m<memo[0][0].length; m++){
                    for(int n=0; n<memo[0][0][0].length; n++){
                        memo[i][j][m][n] = -1;
                    }
                }
            }
        }
    }
    private int opt(char[][] matrix, int i, int j, int m, int n){
        if(memo[i][j][m][n]!=-1) return memo[i][j][m][n];
        if(i==m && j==n) return Integer.parseInt(""+matrix[i][j]);
        int ans = 0;
        // some can only fit horizontal cut, some only vertical cut, and some either works
        // for some that both work, choose one of two is okay
        if(i+1<=m){ // horizontal cut
            int a = opt(matrix, i+1, j, m, n); int b = opt(matrix, i, j, i, n);
            if(a==size(i+1, j, m, n) && b==size(i, j, i, n)) ans = a+b;
        }else if(j+1<=n){ // vertical cut
            int a = opt(matrix, i, j+1, m, n); int b = opt(matrix, i, j, m, j);
            if(a==size(i, j+1, m, n) && b==size(i, j, m, j)) ans = a+b;
        }
        memo[i][j][m][n] = ans;
        return ans;
    }
    private int size(int i, int j, int m, int n){
        return (m-i+1)*(n-j+1);
    }
}
```


Time: O(m^2 * n^2)
Space: O(m^2 * n^2)

### Solution - consecutive pre sum and histogram

1. Calculate consecutive pre sum for each row. For example, consecutive pre sum of `["1","0","1","1","1"]` is `[1,0,1,2,3]`.
2. Start from each point, go upward the column to get the max histogram. For example, column `[3,0,2,2,4]`, start from `i=4`:

i=4: 4*1(4-4+1=1) = 4
i=3: 2*2(4-3+1=2) = 4
i=2: 2*3(4-2+1=3) = 6
i=1: break

So max area is 6.

```
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0) return 0;
        int[][] consecutivePreSum = new int[matrix.length][matrix[0].length];
        init(consecutivePreSum, matrix);
        int max = 0;
        for(int i=0; i<consecutivePreSum.length; i++){
            for(int j=0; j<consecutivePreSum[0].length; j++){
                if(consecutivePreSum[i][j]!=0) max = Math.max(max, histogram(i, j, consecutivePreSum));
            }
        }
        return max;
    }
    private int histogram(int i, int j, int[][] consecutivePreSum){
        int startI = i;
        int minWidth = consecutivePreSum[i][j];
        int maxArea = 0;
        while(i>=0){
            if(consecutivePreSum[i][j]>0){
                minWidth = Math.min(minWidth, consecutivePreSum[i][j]);
                maxArea = Math.max(maxArea, minWidth * (startI-i+1));
                i--;
            }else{
                break;
            }
        }
        return maxArea;
    }
    private void init(int[][] consecutivePreSum, char[][] matrix){
        for(int i=0; i<consecutivePreSum.length; i++){
            for(int j=0; j<consecutivePreSum[0].length; j++){
                if(matrix[i][j]=='1'){
                    if(j-1>=0)  consecutivePreSum[i][j] =  consecutivePreSum[i][j-1] + 1;
                    else        consecutivePreSum[i][j] = 1;
                }else{ // '0'
                     consecutivePreSum[i][j] = 0;
                }
            }
        }
    }
 
    
}
```

m is matrix.length, n is matrix[0].length

Time: O(m^2 * n)
Space: O(m*n)

### Final Solution - Stack

1. Calculate consecutive pre sum for each row. For example, consecutive pre sum of `["1","0","1","1","1"]` is `[1,0,1,2,3]`.
2. For each column, use stack to calculate the max histogram. For example, column `[3,0,4,2]`:
    A. push (-1, 0) into stack
    B. For `i=0`, 3>0, push 0(3) into stack
    C. For `i=1`, 0<3, pop 0(3) from stack, 3*1(1-1--1=1), push 1(0)
    D. For `i=2`, 4>0, push 2(4)
    E. For `i=3`, 2<4, pop 2(4), 4*1(3-1-1=1), push 3(2)
    F. `i=4`, i>=consecutivePreSum.length, pop 3(2), 2*2(4-1-1=2)
    G. `i=4`, i>=consecutivePreSum.length, pop 1(0), 0*4(4-1--1=4)

    max is 4.

    Stack:
    | 3(2)|
    | 2(4)|
    | 1(0)|
    | 0(3)|
    |-1(0)|
    -------
```
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0) return 0;
        int[][] consecutivePreSum = new int[matrix.length][matrix[0].length];
        init(consecutivePreSum, matrix);
        int max = 0;
        for(int j=0; j<consecutivePreSum[0].length; j++){
            max = Math.max(max, histogram(j, consecutivePreSum));
        }
        return max;
    }
    private int histogram(int j, int[][] consecutivePreSum){
        Stack<Status> s = new Stack<>();
        int i = 0;
        int max = 0;
        s.push(new Status(-1, 0));
        while(s.size()>1 || i<consecutivePreSum.length){
            if(i>=consecutivePreSum.length){
                Status pop = s.pop();
                max = Math.max(max, pop.val*(consecutivePreSum.length-1-s.peek().index));
                continue;
            }
            if(consecutivePreSum[i][j]>=s.peek().val){
                s.push(new Status(i, consecutivePreSum[i][j]));
                i++;
            }else{ // consecutivePreSum[i][j] is smaller, pop
                Status pop = s.pop();
                max = Math.max(max, pop.val*(i-1-s.peek().index));
            }
        }
        return max;
    }
    private void init(int[][] consecutivePreSum, char[][] matrix){
        for(int i=0; i<consecutivePreSum.length; i++){
            for(int j=0; j<consecutivePreSum[0].length; j++){
                if(matrix[i][j]=='1'){
                    if(j-1>=0)  consecutivePreSum[i][j] =  consecutivePreSum[i][j-1] + 1;
                    else        consecutivePreSum[i][j] = 1;
                }else{ // '0'
                     consecutivePreSum[i][j] = 0;
                }
            }
        }
    }
}
class Status{
    int index;
    int val;
    public Status(int index, int val){
        this.index = index;
        this.val = val;
    }
}
```

m is matrix.length, n is matrix[0].length

Time: O(m*n)
Sapce: O(m)

## 221. Maximal Square


### Description

### Solution Brute Force

```
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max = 0;
        if(isAllZero(matrix)){
            return 0;
        }else{
            max = 1;
        }
        for(int i=0; i<matrix.length; i++){
            for(int j=0; j<matrix[0].length; j++){
                int maxPossibleLen = Math.min(matrix.length-i, matrix[0].length-j);
                if(matrix[i][j]=='1' && maxPossibleLen*maxPossibleLen>max){
                    int len=2;
                    while(len<=maxPossibleLen){
                        if(isSquareForLen2(i, j, len, matrix) || aroundAllOne(i, j, len, matrix)){
                            max = Math.max(max, len*len);
                            len++;
                        }else{
                            break;
                        }
                    }
                }
            }
        }
        return max;
    }
    private boolean isSquareForLen2(int i, int j, int len, char[][] matrix){
        return len==2 && matrix[i][j]=='1' && matrix[i+1][j]=='1' && matrix[i][j+1]=='1' && matrix[i+1][j+1]=='1';
    }
    private boolean isAllZero(char[][] matrix){
        for(int i=0; i<matrix.length; i++){
            for(int j=0; j<matrix[0].length; j++){
                if(matrix[i][j]=='1'){
                    return false;
                }        
            }
        }
        return true;
    }
    private boolean aroundAllOne(int x, int y, int len, char[][] matrix){
        // right
        for(int j=y; j<y+len; j++){
            if(matrix[x][j]=='0') return false;
        }
        // down
        for(int i=x; i<x+len; i++){
            if(matrix[i][y+len-1]=='0') return false;
        }
        // left
        for(int j=y+len-1; j>=y; j--){
            if(matrix[x+len-1][j]=='0') return false;
        }
        // up
        for(int i=x+len-1; i>=x; i--){
            if(matrix[i][y]=='0') return false;
        }
        return true;
    }
}
```


## 87. Scramble String

### Description

```
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of s1 = "great":

    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t

To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".

    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t

We say that "rgeat" is a scrambled string of "great".

Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".

    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a

We say that "rgtae" is a scrambled string of "great".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

Example 1:

Input: s1 = "great", s2 = "rgeat"
Output: true

Example 2:

Input: s1 = "abcde", s2 = "caebd"
Output: false
```

### First Solution - String (TLE)

Take `rgtae` and `great` as example:

1. divide into 2 substring with i, if i=2, `rgtae.substring(0, 2)` is `rg`, for `great` it's `gr`
2. compare `rg` with `gr` recursively
3. compare left substring of s1 with right substring of s2(of the same sub length), for instance `tae` and `eat`, `t|ae ea|t`, compare `t` with `t`, compare `ae` with `ea`.
4. if length is 1, compare the character.

```
class Solution {
    public boolean isScramble(String s1, String s2) {
        if(s1.length()!=s2.length()) return false;
        int len = s1.length();
        if(len==1) return s1.charAt(0)==s2.charAt(0);
        for(int i=1; i<s1.length(); i++){
            if(isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i, len), s2.substring(i, len))) return true;
            if(isScramble(s1.substring(0, i), s2.substring(len-i, len)) && isScramble(s1.substring(i, len), s2.substring(0, len-i))) return true;
        }
        return false;
    }
}
```

This exceeds time, using DP Memorization is a good way to avoid duplicate computation.

### Improved Solution 1 - String

Add check in the begining to avoid TLE, to check if they have the same number of each letter. This assumes only 26 letters in s1 and s2.

```
class Solution {
    public boolean isScramble(String s1, String s2) {
        if(check(s1, s2)==false) return false;
        int len = s1.length();  // if length different, check will return false
        if(len==1) return s1.charAt(0)==s2.charAt(0);
        for(int i=1; i<s1.length(); i++){
            if(isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i, len), s2.substring(i, len))) return true;
            if(isScramble(s1.substring(0, i), s2.substring(len-i, len)) && isScramble(s1.substring(i, len), s2.substring(0, len-i))) return true;
        }
        return false;
    }
    private boolean check(String s1, String s2){
        int[] map = new int[26];
        for(int i=0; i<s1.length(); i++) map[s1.charAt(i)-'a']++;
        for(int i=0; i<s2.length(); i++) map[s2.charAt(i)-'a']--;
        for(int i=0; i<map.length; i++){
            if(map[i]!=0) return false;
        }
        return true;
    }
}
```

### Improved Solution 2(Final Solution) - DP Memorization

The Memorization I used for `String s1, String` is (str in alphabetical order, set of scrambles). It's TLE since sort String alphabetically add O(n) time complexity to each recursion.

Refactor `isScramble` from `String s1, String s2` to `String s1, int start1, int end1, String s2, int start2, int end2`, to `String s1, int start1, String s2, int start2, int len`.

So the `memo` is simply `(start1, start2, len)`.

The logic for `isScramble` is similiar.

1. divide into 2 parts with `subLen`.
2. compare left of s1 with left of s2(length is `subLen`), right of s1 with right s2(length is `len-subLen`). If true then return true.
3. compare left of s1 with right of s2(length is `subLen`), right of s1 with left of s2(length is `len-subLen`). If true then return true.
4. If length is 1, simply compare character.

```
class Solution {
    private int[][][] memo; // 0 is default, 1 is true, -1 is false
    public boolean isScramble(String s1, String s2) {
        if(s1.length()!=s2.length()) return false;
        int wordLen = s1.length();
        memo = new int[wordLen][wordLen][wordLen+1]; // (start1, start2, len)
        return isScramble(s1, 0, s2, 0, wordLen);
    }
    private boolean isScramble(String s1, int start1, String s2, int start2, int len) {
        if(len==1) return s1.charAt(start1)==s2.charAt(start2);
        if(memo[start1][start2][len]!=0) return memo[start1][start2][len]==1?true:false;
        boolean ans = false;
        for(int subLen = 1; subLen<len; subLen++){
            if(isScramble(s1, start1, s2, start2, subLen) && isScramble(s1, start1+subLen, s2, start2+subLen, len-subLen)){
                ans = true;
                break;
            }
            if(isScramble(s1, start1, s2, start2+len-subLen, subLen) && isScramble(s1, start1+subLen, s2, start2, len-subLen)){
                ans = true;
                break;
            }
        }
        memo[start1][start2][len] = ans==true?1:-1;
        return ans;
    }
}
```

## 91. Decode Ways

### First Solution DP + Memorization (2D)

1. cur-start==0. If cur points to `0`, count+=0. Otherwise, there can be 2 possiblities.
    A. cut
    B. If the number of cur and next <= 26, not cut now
2. cur-start==1: must cut. 

And use `int[][] memo` to do memorization to save duplciate computation.


```
class Solution {
    private int[][] memo; // default is -1
    public int numDecodings(String s) {
        memo = new int[s.length()][s.length()]; // start, cur => numDecodings
        for(int i=0; i<memo.length; i++){
            for(int j=0; j<memo[0].length; j++) memo[i][j] = -1;
        }
        if(s.length()==0) return 0;
        return numDecodings(s, 0, 0);
    }
    public int numDecodings(String s, int start, int cur) {
        if(cur>=s.length()) return 1;
        if(memo[start][cur]!=-1) return memo[start][cur];
        int count = 0;
        if(cur-start==0){
            if(s.charAt(cur)!='0'){
                count += numDecodings(s, cur+1, cur+1); // cut
                if(cur+2<=s.length() && Integer.parseInt(s.substring(cur, cur+2))<=26){
                    count += numDecodings(s, cur, cur+1); // not cut
                }    
            }
        }else if(cur-start==1){ // must cut
            count += numDecodings(s, cur+1, cur+1);
        }
        memo[start][cur] = count;
        return count;
    }
}
```

### Final Solution

opt(i) is number of ways to decode String (s_i s_i+1 ... s_len-1)

```
class Solution {
    public int numDecodings(String s) {
        int[] opt = new int[s.length()+1]; // opt(i) is number of ways to decode String s_i s_i+1 ... s_len-1
        opt[s.length()] = 1; // cut and decoded finished, this is one valid way
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)=='0') opt[i] = 0;
            else{
                // i+1: decode [si], all after i is in doubt.
                // i+2: decode [s_i s_i+1], all after i+1 is in doubt.
                if(i+2<opt.length&&Integer.parseInt(s.substring(i, i+2))<=26) opt[i] = opt[i+1]+opt[i+2];
                else opt[i] = opt[i+1];
            }
        }
        return opt[0];
    }
}
```

## 120. Triangle

### Description

```
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:

Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
```

### First Solution 2D DP

opt(i, j) is the minimum path sum from 0th row to ith row and select j in ith row.

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int rowLen = triangle.size();
        if(rowLen==0) return 0;
        int maxColLen = triangle.get(rowLen-1).size();
        int[][] opt = new int[rowLen][maxColLen];
        opt[0][0] = triangle.get(0).get(0);
        for(int i=1; i<rowLen; i++){
            for(int j=0; j<triangle.get(i).size(); j++){
                int val = triangle.get(i).get(j);
                boolean jExist = j<triangle.get(i-1).size();
                boolean preJExist = j-1>=0;
                if(jExist && preJExist) opt[i][j] = val + Math.min(opt[i-1][j], opt[i-1][j-1]);
                if(jExist && !preJExist) opt[i][j] = val + opt[i-1][j];
                if(!jExist && preJExist) opt[i][j] = val + opt[i-1][j-1];
                // the case j and j-1 both not exist won't happen
            }
        }
        int min = opt[maxColLen-1][0];
        for(int j=0; j<maxColLen; j++){
            min = Math.min(min, opt[rowLen-1][j]);
            
        }
        return min;
    }
}
```

### Improve from 2D to 1D DP (Final Solution)

opt(j) is the min path sum for column j.

There are three statements using opt. And everytime I actually use `i-1` to compute i's opt. So I can easily get rid of `i-1` and adjust to `j--` to make sure `opt(j-1)` for this `i` is computed after computing `opt(j)`, since sometimes I use ` opt[i-1][j-1]` to compute `opt[i][j]`.

From:

```
if(jExist && preJExist) opt[i][j] = val + Math.min(opt[i-1][j], opt[i-1][j-1]);
if(jExist && !preJExist) opt[i][j] = val + opt[i-1][j];
if(!jExist && preJExist) opt[i][j] = val + opt[i-1][j-1];
```

To:

```
if(jExist && preJExist) opt[j] = val + Math.min(opt[j], opt[j-1]);
if(jExist && !preJExist) opt[j] = val + opt[j];
if(!jExist && preJExist) opt[j] = val + opt[j-1];
```

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int rowLen = triangle.size();
        if(rowLen==0) return 0;
        int maxColLen = triangle.get(rowLen-1).size();
        int[] opt = new int[maxColLen];
        opt[0] = triangle.get(0).get(0);
        for(int i=1; i<rowLen; i++){
            // if j from 0 to len-1 then opt[j] will use opt[j-1], which has been updated before
            for(int j=triangle.get(i).size()-1; j>=0; j--){
                int val = triangle.get(i).get(j);
                boolean jExist = j<triangle.get(i-1).size();
                boolean preJExist = j-1>=0;
                if(jExist && preJExist) opt[j] = val + Math.min(opt[j], opt[j-1]);
                if(jExist && !preJExist) opt[j] = val + opt[j];
                if(!jExist && preJExist) opt[j] = val + opt[j-1];
                // the case j and j-1 both not exist won't happen
            }
        }
        int min = opt[0];
        for(int j=1; j<maxColLen; j++){
            min = Math.min(min, opt[j]);
            
        }
        return min;
    }
}
```

## 139. Word Break

### Description

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

### Final Solution (DP+Memorization)

1. Find the words that match with the prefix of s.
2. Call `wordBreak` recursively with each `s.substring(w.length())`, either return true then true
3. End condition: if finally s is empty, then it shows just used up. Otherwise I cannot find match words and return false after for loop.
4. Use memo to memorize (substring, can be nicely segmented or not)

```
class Solution {
    private Map<String, Boolean> memo = new HashMap<>(); // (string, can be nicely segmented or not)
    public boolean wordBreak(String s, List<String> wordDict) {
        if(s.length()==0) return true;
        if(memo.get(s)!=null) return memo.get(s);
        List<String> words = getMatchWords(s, wordDict);
        boolean ans = false;
        for(String w: words){
            if(wordBreak(s.substring(w.length()), wordDict)==true){
                ans = true;
                break;
            }
        }
        memo.put(s, ans);
        return ans;
    }
    private List<String> getMatchWords(String s, List<String> wordDict){
        List<String> ans = new ArrayList<>();
        for(String w: wordDict){
            if(s.startsWith(w)) ans.add(w);
        }
        return ans;
    }
}
```


Hard to calculate time complexity and space complexity.

### Bonus: DP Solution

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // opt(i) is whether s0 s1 ... si can be segmented.
        boolean[] opt = new boolean[s.length()];
        Set<String> wordSet = new HashSet<>(wordDict);
        for(String w: wordSet){
            if(w.length() <= s.length() && s.substring(0, w.length()).equals(w)) opt[w.length()-1] = true;
        }
        for(int i=0; i<s.length(); i++){
            for(int j=0; j<i; j++){
                if(opt[j] && wordSet.contains(s.substring(j+1, i+1))){
                    opt[i] = true;
                    break;
                }
            }
        }
        return opt[s.length()-1];
    }
}
```

### Bonus: Improved DP Solution

opt(i) is whether s_0 s_1 ... s_i-1 can be segmented. Leave out opt[0] to set to true and start the compare. `opt[i]=opt[j] && wordSet.contains(s.substring(j+1, i+1))`

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // opt(i) is whether s_0 s_1 ... s_i-1 can be segmented.
        boolean[] opt = new boolean[s.length()+1];
        Set<String> wordSet = new HashSet<>(wordDict);
        opt[0] = true; // s_-1 can be segmented, no meaning, just to start the compare
        for(int i=1; i<=s.length(); i++){
            for(int j=0; j<i; j++){
                if(opt[j] && wordSet.contains(s.substring(j, i))){
                    opt[i] = true;
                    break;
                }
            }
        }
        return opt[s.length()];
    }
}
```


Time: O(n^3)
Space: O(n)

## 140. Word Break II

### Description

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]
Example 2:

Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.
Example 3:

Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]
```

### Final Solution

1. find matched words
2. for each w, call `recursion(s.substring(w.length()))` to get `List<StringBuilder>`, for each sb in list, insert w and space to begining of sb. combine all lists into one and return.
3. Use memo to memorize (str, list of possible sentence(list of sb)), be carefully to deepClone list of StringBuilder when put into memo and get from memo to avoid changes on StringBuilder update sb in memo.

```
class Solution {
    private Map<String, List<StringBuilder>> memo = new HashMap<>(); // (str, list of possible sentence)
    public List<String> wordBreak(String s, List<String> wordDict) {
        List<StringBuilder> l = recursion(s, wordDict);
        List<String> ans = new ArrayList<>();
        for(StringBuilder sb: l){
            ans.add(sb.substring(1));
        }
        return ans;
    }
    public List<StringBuilder> recursion(String s, List<String> wordDict) {
        if(s.length()==0) return new ArrayList<StringBuilder>(){{add(new StringBuilder());}};
        // must use deepClone, since the sb in returned res will be inserted and update that in memo
        if(memo.get(s)!=null) return deepClone(memo.get(s));
        List<StringBuilder> ans = new ArrayList<>();
        List<String> words = getMatchWords(s, wordDict);
        for(String w: words){
            List<StringBuilder> res = recursion(s.substring(w.length()), wordDict);
            for(StringBuilder sb: res){
                sb.insert(0, w); sb.insert(0, " ");
            }
            ans.addAll(res);
        }
        // must use deepClone, since the ans will be inserted and update that in memo
        memo.put(s, deepClone(ans));
        return ans;
    }
    private List<StringBuilder> deepClone(List<StringBuilder> l){
        List<StringBuilder> copy = new ArrayList<>();
        for(StringBuilder sb: l){
            copy.add(new StringBuilder(sb));
        }
        return copy;
    }
    private List<String> getMatchWords(String s, List<String> wordDict){
        List<String> ans = new ArrayList<>();
        for(String w: wordDict){
            if(s.startsWith(w)) ans.add(w);
        }
        return ans;
    }
}
```


Time and space complexity? Have to read docs or watch videos for the analysis for DP memorization. Or transfer to DP to analyze the time complexity?

Time: O(n^3). Convert to DP.

```
size(i) from 1 to s.length
    start(j) from 0 to s.length-i
        sub = s[j, i]
        opt(i) = each one in opt(j) + sub, if wSet contains sub
```

i is O(n), j is O(n), `s[j, i]` is O(n), each one in opt(j) is O(n), so O(n^3)


Space: O(n^3). key is O(n), list of String is O(n^2).

## 152. Maximum Product Subarray

### Description

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

### First Solution MLE

opt(i, j) is the product from nums[i](inclusive) to nums[j](exclusive).

```
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length==0) return 0;
        int[][] opt = new int[nums.length][nums.length+1];
        for(int i=0; i<nums.length; i++) opt[i][i] = 1;
        int max = nums[0];
        for(int i=0; i<nums.length; i++){
            for(int j=i+1; j<=nums.length; j++){
                opt[i][j] = opt[i][j-1] * nums[j-1];
                max = Math.max(max, opt[i][j]);
            }
        }
        return max;
    }
}
```

Time: O(n^2)
Space: O(n^2)

### Final Solution (DP + minmax)

`opt[i][0]` is the minimum product of subarray from index 0 to i(inclusive), `opt[i][1]` is the maximum product of subarray from index 0 to i(inclusive).

MINMAX: `negative i-1 min` * `negtive nums[i]` > `positive i-1 max` * `negative nums[i]`.

If min of `i-1` is minus, and `nums[i]` is also minus, then product will be positive number, it's larger than positive*negtive, even positive is max for `i-1`

For example, [1,-2,3,-4]

Only remember max: 1, -2, 3, -4, max is 3

Remember max and min: (1,1),(-2,-2),(-6,3),(-12,24), max is 24


```
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length==0) return 0;
        // opt[i][0] is the min product of subarray ending in index i, 1 stands for max
        int[][] opt = new int[nums.length][2];
        for(int i=0; i<nums.length; i++){
            if(i-1>=0){
                opt[i][0] = min(nums[i], opt[i-1][0]*nums[i], opt[i-1][1]*nums[i]);
                opt[i][1] = max(nums[i], opt[i-1][0]*nums[i], opt[i-1][1]*nums[i]);
            }else{
                opt[i][0] = nums[i];
                opt[i][1] = nums[i];
            }
        }
        int max = nums[0];
        for(int i=0; i<opt.length; i++){
            max = Math.max(max, opt[i][1]);
        }
        return max;
    }
    private int max(int a, int b, int c){
        return Math.max(a, Math.max(b, c));
    }
    private int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
}
```


Time: O(n)
Space: O(n)

## 213. House Robber II

### Description

```
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
Example 2:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.

```

### Final Solution - DP

opt(i, j) is the maximum amount of money robbed one night for house 0 to house i, j==1 means last house is robbed, j==0 means last house isn't robbed.

opt(i, j) = max(
    opt(i-2, j) + nums[i]   // rob i
    opt(i-1, j)             // not rob i
)

If i==0,
 opt(0, 1) = 0          // last is robbed and adjacent to first one, so first one cannot be robbed
 opt(0, 0) = nums[0]    // last one is not robbed, so must rob first one to maximize money


If i==len-1
 opt(i, 0) = opt(i-1, 0)            // not rob last one(i)
 opt(i, 1) = opt(i-2, 1) + nums[i]  // rob last one

return max{opt(len-1, 0), opt(len-1, 1)}

Only when len>=3 then the statement `opt[i][1] = opt[i-2][1] + nums[i]` where i is len-1 can work. So I have to deal with  cases when len is 0, 1, 2 separately.

```
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len==0) return 0;
        if(len==1) return nums[0];
        if(len==2) return Math.max(nums[0], nums[1]);
        int[][] opt = new int[len][2];
        opt[0][0] = nums[0];
        opt[0][1] = 0;
        for(int j=0; j<=1; j++) opt[1][j] = Math.max(nums[1], opt[0][j]);
        int i=2;
        for(; i<len-1; i++){
            for(int j=0; j<=1; j++){
                opt[i][j] = Math.max(opt[i-2][j]+nums[i], opt[i-1][j]);
            }
        }
        // i is len-1
        opt[i][0] = opt[i-1][0];
        opt[i][1] = opt[i-2][1] + nums[i];
        return Math.max(opt[i][0], opt[i][1]);
    }
}
```

Time: O(n)
Space: O(n)

## 264. Ugly Number II

### Description

Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. 

Example:

Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note:  

1 is typically treated as an ugly number.
n does not exceed 1690.

### First Solution DP+Map - TLE

Use map because I don't know how many times final (i-1)/n can be, previously I used 2*n but exceeds.

```
class Solution {
    public int nthUglyNumber(int n) {
        if(n==0) return 0;
        Map<Integer, Boolean> opt = new HashMap<>(); // (i, is ugly number or not)
        int i=1;
        int count=0;
        while(count<n){
            if(isUglyNumber(i, opt)){
                count++;
            }
            i++;
        }
        return i-1;
    }
    private boolean isUglyNumber(int i, Map<Integer, Boolean> opt){
        if(i%2==0){
            opt.put(i, opt.get(i/2));
        }else if(i%3==0){
            opt.put(i, opt.get(i/3));
        }else if(i%5==0){
            opt.put(i, opt.get(i/5));
        }else{
            opt.put(i, i==1);
        }
        return opt.get(i);
    }
}
```

### Final Solution - pre compute + 3 pointers + DP

Use static to pre compute result for each possible input n since `n<=1690`.

opt(i) is the ith ugly number.



```
// 3 pointers
class Solution {
    private static int[] opt = preCompute();
    private static int[] preCompute(){
        int[] opt = new int[1691];
        opt[1] = 1;
        int n = 2;
        int i2 = 1;
        int i3 = 1;
        int i5 = 1;
        while(n<opt.length){
            // use opt[i] because idx cannot be number like 7, must use valid number, which is all in opt
            opt[n] = min(opt[i2]*2, opt[i3]*3, opt[i5]*5);
            if(opt[n]==opt[i2]*2) i2++;
            if(opt[n]==opt[i3]*3) i3++;
            if(opt[n]==opt[i5]*5) i5++;
            n++;
        }
        return opt;
    }
    private static int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
    public int nthUglyNumber(int n) {
        return opt[n];
    }
}
```