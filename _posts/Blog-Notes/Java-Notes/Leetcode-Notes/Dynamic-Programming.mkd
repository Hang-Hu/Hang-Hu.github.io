## 279. Perfect Squares

### Description

```
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

### Best Solution - DP

OPT(i) = min k=1,2,3...&&k^2<=i {OPT(i-k^2)+OPT(k^2)}

Have to init opt[0] and opt[k^2].

```
class Solution {
    public int numSquares(int n) {
        int[] opt = new int[n+1];
        opt[0] = 0;
        // init opt when it comes to square numbers, the number used is just 1
        for(int k=1; k*k<=n; k++)    opt[k*k] = 1;
        for(int i=1; i<=n; i++){
            int min = Integer.MAX_VALUE;
            for(int k=1; k*k<=i; k++){
                int tmp = opt[i-k*k]+opt[k*k];
                if(tmp<min) min=tmp;
            }
            opt[i] = min;
        }
        return opt[n];
    }
}
```

## 72. Edit Distance

### Description

```
Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

### Solution

ignore x, y == delete x, y

delete x == insert y

replace x with y == replace y with x

So insert, delete and replace can be replace by ignoring x(-), ignoring y(|) and replacing(/).

`opt(i, j)` is the minimum cost spent when changing string x1...xi to y1...yj(0 is left for empty string)

if i=0, diff(empty, y1...yj): j
if j=0, diff(x1...xi, empty): i

```
opt(i, j) = min(
                opt(i-1, j-1)+0(xi==yj)/1(xi!=yj)
                opt(i-1, j)+1
                opt(i, j-1)+1
            )
```

```
class Solution {
    public int minDistance(String word1, String word2) {
        if(word1.length()==0) return word2.length();
        if(word2.length()==0) return word1.length();
        int[][] opt = new int[word1.length()+1][word2.length()+1];
        for(int i=0; i<opt.length; i++) opt[i][0] = i;
        for(int j=0; j<opt[0].length; j++) opt[0][j] = j;
        for(int i=1; i<opt.length; i++){
            for(int j=1; j<opt[0].length; j++){
                opt[i][j] = min(opt[i-1][j-1]+(word1.charAt(i-1)==word2.charAt(j-1)?0:1), opt[i-1][j]+1, opt[i][j-1]+1);
            }
        }
        return opt[opt.length-1][opt[0].length-1];
    }
    private int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
}
```

## 5. Longest Palindromic Substring

### Description

```
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
```

### Solution - DP

`opt(i, j)` is boolean, whether `s.substring(i, j+1)` is palindrome or not. Both i and j are inclusive

Length 1 word `(i, i)` and length 2 word `(i, i+1)` are set by for loop.

Then the length grows from `opt[i+1][i+x-1]` to `opt[i][i+x]`, which grows by 2. For example, from length 1 to 3, to 5, etc. And length 2 to 4, to 6, etc. Then I grow word's length from 1, 2 to 3,4,5,etc.

Finally just check the max of `j-i+1` where `opt(i, j)` is `true`.

Note that due to dependency of `opt[i+1][i+x-1]` to calculate `opt[i][i+x]`, I have to calculate crossly to final one slot.

Calculate in the following order.

1. (0, 2), (1, 3), (2, 4) // +2
2. (0, 3), (1, 4) // +3
3. (0, 4) //+4

```
| j\i | 0 | 1 | 2 | 3 | 4 |
|-----|---|---|---|---|---|
| 0   | T |   |   |   |   |
| 1   | F | T |   |   |   |
| 2   |   | F | T |   |   |
| 3   |   |   | F | T |   |
| 4   |   |   |   | F | T |
```

```
class Solution {
    public String longestPalindrome(String s) {
        int length = s.length();
        if(length==0) return "";
        boolean[][] opt = new boolean[length][length];
        for(int i=0; i<length; i++) opt[i][i] = true;
        for(int i=0; i+1<length; i++) opt[i][i+1] = (s.charAt(i)==s.charAt(i+1));
        for(int x=2; x<length; x++){
            for(int i=0; i+x<length; i++){
                opt[i][i+x] = (opt[i+1][i+x-1] && (s.charAt(i)==s.charAt(i+x)));
            }
        }
        int max = 0;
        int start = -1;
        int end = -1;
        for(int i=0; i<length; i++){
            for(int j=i; j<length; j++){
                if(opt[i][j] && j-i+1>max){
                    max = j-i+1;
                    start = i;
                    end = j;
                }
            }
        }
        return s.substring(start, end+1);

    }
}
```

Time: O(n^2). (n-2)^2/2 = O(n^2). Nearly half of the square.
Space: O(n^2).

### Final Solution - Recursion

Grow from one letter, grow if `s[i-1]==s[j+1]`, grow() return length, start and end index. Then grow from 2 letters if they are the same. This will cover 1,3,5 and 2,4,6 so covers every number. Finally compare the length and return the string of max length.

```
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()==0) return "";
        int max = 0;
        int start = -1;
        int end = -1;
        for(int i=0; i<s.length(); i++){
            Position res = grow(i, i, s);
            if(res.length>max){
                max = res.length;
                start = res.start;
                end = res.end;
            }
        }
        for(int i=0; i+1<s.length(); i++){
            if(s.charAt(i)!=s.charAt(i+1)) continue;
            Position res = grow(i, i+1, s);
            if(res.length>max){
                max = res.length;
                start = res.start;
                end = res.end;
            }
        }
        return s.substring(start, end+1);
    }
    // start, end are inclusive
    private Position grow(int start, int end, String s){
        if(start-1>=0&&end+1<s.length()&&s.charAt(start-1)==s.charAt(end+1)) return grow(start-1, end+1, s);
        return new Position(end-start+1, start, end);
    }
}
class Position{
    int length;
    int start;
    int end;
    public Position(int length, int start, int end){
        this.length = length;
        this.start = start;
        this.end = end;
    }
}
```

Time: O(n^2)
Space: O(1)

## 338. Counting Bits

### Description

```
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

Example 1:

Input: 2
Output: [0,1,1]
Example 2:

Input: 5
Output: [0,1,1,2,1,2]
Follow up:

It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
Space complexity should be O(n).
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
```

### Solution Naive

```
class Solution {
    public int[] countBits(int num) {
        int[] ans = new int[num+1];
        for(int i=0; i<=num; i++){
            ans[i] = numOfOnes(i);
        }
        return ans;
    }
    private int numOfOnes(int num){
        int count = 0;
        while(num>0){
            count+=(num&1);
            num = num>>>1;
        }
        return count;
    }
}
```

Time: O(n\*logn). Since logn is the number of bits(size) for n.
Space: O(n)

### Final Solution - DP

opt(i) = last digit(1/0) + opt(i remove last digit). Since after removing last digit it's smaller than i, then that opt already exist, this saves time by reusing previous result.

```
class Solution {
    public int[] countBits(int num) {
        int[] opt = new int[num+1];
        for(int i=0; i<=num; i++) opt[i] = (i&1) + opt[i>>>1]; // have to use () for i&1 otherwise + will be executed first
        return opt;
    }
}
```

Time: O(n)
Space: O(n)

## 32. Longest Valid Parentheses

### Description

```
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

### Solution - Brute Force(TLE)

```
class Solution {
    public int longestValidParentheses(String s) {
        int max = 0;
        // i, j inclusive
        for(int i=0; i<s.length(); i++){
            for(int j=i+1; j<s.length(); j++){
                if(valid(s, i, j)) max = Math.max(max, j-i+1);
            }
        }
        return max;
    }
   // start, end inclusive
    private boolean valid(String s, int start, int end){
        int l = 0;
        int r = 0;
        for(int i=start; i<=end; i++){
            if(s.charAt(i)=='('){
                if(r>0) return false;
                else    l++;
            }else if(s.charAt(i)==')'){
                if(l>0) l--;
                else    return false;
            }
        }
        return l==0 && r==0;
    }
}
```

Time: O(n^3)

Space: O(1)

### Solution DP

If s[i-1]=='(': opt[i] = 2+opt[i-2]; // may-be-valid()
If s[i-1-opt[i-1]]=='(': opt[i] = 2+opt[i-1]+opt[i-1-opt[i-1]-1];// may-be-valid(valid-inside)

```
class Solution {
    public int longestValidParentheses(String s) {
        if(s.length()==0||s.length()==1) return 0;
        int[] opt = new int[s.length()];
        opt[0]=0;
        if(s.charAt(1)=='('){
            opt[1] = 0;
        }else{ // )
            if(s.charAt(0)=='(')    opt[1] = 2; //()
            else                    opt[1] = 0; //))
        }
        for(int i=2; i<s.length(); i++){
            if(s.charAt(i)=='('){
                opt[i] = 0;
            }else{ // )
                if(s.charAt(i-1)=='('){ // may-be-valid()
                    opt[i] = 2+opt[i-2];
                }else{ // ))
                    if(i-1-opt[i-1]>=0 && s.charAt(i-1-opt[i-1])=='('){ // may-be-valid(valid-inside)
                        if(i-1-opt[i-1]-1>=0)   opt[i] = 2+opt[i-1]+opt[i-1-opt[i-1]-1];
                        else                    opt[i] = 2+opt[i-1];
                    }else{ // )) or valid-inside))
                        opt[i] = 0;
                    }
                }
            }
        }
        int max = 0;
        for(int i=0; i<opt.length; i++){
            max = Math.max(max, opt[i]);
        }
        return max;
    }
}
```

Time: O(n)
Space: O(n)

### Final Solution - l==r

Walk throught string with one index. Only increment l and r, once invalid(r>l) reset l and r. Then walk through from length-1 to 0. l==r shows it's a valid substring, compare l+r with max.

```
class Solution {
    public int longestValidParentheses(String s) {
        int l = 0;
        int r = 0;
        int max = 0;
        for(int i=0; i<s.length(); i++){
            if(s.charAt(i)=='('){
                l++;
            }else{
                r++;
                if(r>l){
                    l = 0; r = 0;
                }
            }
            if(l==r) max = Math.max(max, l+r);
        }
        l = 0; r = 0;
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)=='('){
                l++;
                if(l>r){
                    l = 0; r = 0;
                }
            }else{
                r++;
            }
            if(l==r) max = Math.max(max, l+r);
        }
        return max;
    }
}
```

## 10. Regular Expression Matching

### Description

```
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
Example 4:

Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
Example 5:

Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
```

### Solution DP(Recursion+Memorization)

Be careful I have many choices for one case, for example, a* can match 0 which is "", or match "a" or match "aaa...". And the differnt matching of a* will influence next matching, for example, the matching of b\* following it.

Why Backtracking? some path not call and try because not meet condition.

If i, j exceed limit: true(i, j finish successfully)
If j exceed i not: false(nothing to match anymore, but i not finish, so false)
If j not i finish: maybe it's multiple x* and can be treated as 0 match, so continue.
firstMatch: the same or j is .
If j+1 is *:

1.  match 0 time: i the same, j+2(skip char and \*)
2.  match 1 or more time(only if firstMatch): i+1(next char), j the same
    If j+1 isnot _:
    only if firstMatch, both go to next one(i+1, j+1) (if j+1 is _ and firstMatch, for example a and a\*, then I can use match 1 and match 0 to solve it, so I have to skip it here, otherwise will be duplicate computation, even it's dp and the earlier one have the true computation, I don't even want to call dup)

memo[i][j] uses `s.length()+1` since i may exceed, and since i+1 it will at most exceed one, uses `p.length()` since as long as j exceeds, it returns and not call memo using j.

Since i may exceed, but still valid when nextIsStar and match 0, so have to check i limitation before calling it with memo.

I used `int[][]` instead of `boolean[][]` because I need the default to know if it's has already been calculated or not.

The bottom up dp is very similiar, just calc memo[i][j] for each grid.

```
class Solution {
    int[][] memo; // 0 is default, 1 is true, -1 is false
    public boolean isMatch(String s, String p) {
        memo = new int[s.length()+1][p.length()];
        return isMatch(s, 0, p, 0);
    }
    private boolean isMatch(String s, int i, String p, int j){
        if(j>=p.length() && i>=s.length()) return true;
        if(j>=p.length() && i<s.length()) return false;
        if(memo[i][j]!=0) return memo[i][j]==1?true:false;
        boolean firstMatch = i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='.');
        boolean nextIsStar = j+1<p.length() && p.charAt(j+1)=='*';
        boolean ans = false;
        if(nextIsStar){ // x*, x can be . or any char
            ans = isMatch(s, i, p, j+2); // * match 0 of p[j]
            ans = ans || (firstMatch && isMatch(s, i+1, p, j)); // * match 1 or more of p[j]
        }else{ // point to same char or p[j] is ., then p[j] matches s[i]
            ans = firstMatch && isMatch(s, i+1, p, j+1);
        }
        memo[i][j] = ans==true?1:-1;
        return ans;
    }
}
```

m is s.length(), n is p.length().

Time: O(m*n), calculate each grid in memo[i][j] once, each takes O(1) time to calc.
Space: I(m*n)

## 44. Wildcard Matching

### Description

```
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "*"
Output: true
Explanation: '*' matches any sequence.
Example 3:

Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
Example 4:

Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
Example 5:

Input:
s = "acdcb"
p = "a*c?b"
Output: false
```

### Final Solution DP (Recursion+Memorization)

Similiar to 10.Regular Expression Matching.

If j is \*, try match 0(j+1) and match 1 or more(i+1)
Otherwise check if first match, yes then try next pari(i+1, j+1)

Use int[][] memo to memory duplicate computation.

```
class Solution {
    private int[][] memo; // 0 is default, 1 is true, -1 is default
    public boolean isMatch(String s, String p) {
        // p exceed will return without calling memo, i exceed will call memo with i
        memo = new int[s.length()+1][p.length()];
        return isMatch(s, 0, p, 0);
    }
    private boolean isMatch(String s, int i, String p, int j){
        if(i>=s.length() && j>=p.length()) return true;
        if(i<s.length() && j>=p.length()) return false;
        if(memo[i][j]!=0) return memo[i][j]==1?true:false;
        boolean firstMatch = i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='?');
        boolean isStar = p.charAt(j)=='*';
        boolean ans = false;
        if(isStar){
            ans = isMatch(s, i, p, j+1); // match 0
            // match 1 or more, i have to be within limit so that can be matched by *
            ans = ans || (i<s.length() && isMatch(s, i+1, p, j));
        }else{
            ans = firstMatch && isMatch(s, i+1, p, j+1);
        }
        memo[i][j] = ans==true?1:-1;
        return ans;
    }
}
```

m is s.length(), n is p.length()

Time: O(m*n)
Space: I(m*n)

### Solution (KMP)

First time meet _, match 0 time. If encounter firstMatch is false, i and j go back to previous _, match time inc by 1. If all remaining j is \*, then return true.

```
class Solution {
    public boolean isMatch(String s, String p) {
        int i=0, j=0, preStarIndexOfI=-1, preStarIndexOfJ=-1, matchNum=-1;
        while(i<s.length() && j<p.length()+1){ // j can exceed so that j can go back to use last * which is in len-1
            boolean firstMatch = j<p.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='?');
            boolean isStar = j<p.length() && (p.charAt(j)=='*');
            if(isStar){
                preStarIndexOfI = i;
                preStarIndexOfJ = j;
                matchNum = 0;
                j++; // match 0 time
            }else{
                if(firstMatch){
                    i++; j++;
                }else{
                    if(preStarIndexOfJ==-1) return false;
                    j = preStarIndexOfJ;
                    i = preStarIndexOfI;
                    matchNum++;
                    i += matchNum;
                    j++;
                }
            }
        }
        if(i>=s.length()){
            while(j<p.length()){
                if(p.charAt(j)!='*') return false;
                j++;
            }
            return true;
        }else{ // j>=p.length()+1
            return false;
        }

    }
}
```

## 62. Unique Paths

### Description

```
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
```

### Final Solution DP

opt(i, j) is the number of ways to reach bottom right corner(m-1, n-1) from position (i, j).

```
(i, j)      (i+1, j)
(i, j+1)
```

```
opt(i, j) = opt(i+1, j)(if i+1 exist) + opt(i, j+1)(if j+1 exist)
```

Why use i+1 and j+1 exist condition?

The position of i+j may be in boundary, for example, i=m-1, j=1, then they only have bottom no right.

`opt[m-1][n-1]` is 1 because `opt[m-2][n-2]` is definitly 2 ways, from right and from bottom, and it equals `opt[m-1][n-2]+opt[m-2][n-1]`, each should be one. And `opt[m-1][n-2]` equals `opt[m-1][n-1]` since it has no right way to bottom right corner. So `opt[m-1][n-1]` is 1.

```
(m-2, n-2)  (m-1, n-2)
(m-2, n-1)  (m-1, n-1)
```

```
class Solution {
    public int uniquePaths(int m, int n) {
        if(m==0 || n==0) return 0;
        int[][] opt = new int[m][n];
        opt[m-1][n-1] = 1;
        for(int i=m-1; i>=0; i--){
            for(int j=n-1; j>=0; j--){
                if(i+1<m) opt[i][j] += opt[i+1][j];
                if(j+1<n) opt[i][j] += opt[i][j+1];
            }
        }
        return opt[0][0];
    }
}
```

## 63. Unique Paths II

### Description

```
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?



An obstacle and empty space is marked as 1 and 0 respectively in the grid.

Note: m and n will be at most 100.

Example 1:

Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right

```

### Final Solution - DP

opt(i, j) is the number of ways to reach bottom right corner(m-1, n-1) from position (i, j).

```
(i, j)      (i+1, j)
(i, j+1)
```

```
opt(i, j) = opt(i+1, j)(if i+1 exist and obstacle[i][j] is 0) + opt(i, j+1)(if j+1 exist and obstacle[i][j] is 0)
```

```
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int[][] opt = new int[obstacleGrid.length][obstacleGrid[0].length];
        if(obstacleGrid[opt.length-1][opt[0].length-1]==1) return 0; // if finish is obstacle, there is no way to be there
        opt[opt.length-1][opt[0].length-1] = 1;
        for(int i=opt.length-1; i>=0; i--){
            for(int j=opt[0].length-1; j>=0; j--){
                if(obstacleGrid[i][j]==0){ // if it's obstacle, no need to compute number of ways
                    if(i+1<opt.length && obstacleGrid[i+1][j]==0) opt[i][j] += opt[i+1][j];
                    if(j+1<opt[0].length && obstacleGrid[i][j+1]==0) opt[i][j] += opt[i][j+1];
                }
            }
        }
        return opt[0][0];
    }
}
```

## 64. Minimum Path Sum

### Description

```
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.

```

### Final Solution - DP

opt(i, j) is the minimum path sum from (i, j) to (m-1, n-1).

```
(i, j)      (i, j+1)
(i+1, j)    (i+1, j+1)
```

```
opt(i, j) = grid(i, j) + min{opt(i+1, j)(if i+1 exist), opt(i, j+1)(if j+1 exist)}
```

opt(m-1, n-1) = grid(m-1, n-1).

return opt(0, 0).

```
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] opt = new int[m][n];
        for(int i=m-1; i>=0; i--){
            for(int j=n-1; j>=0; j--){
                opt[i][j] = grid[i][j];
                int min = -1;
                if(j+1<n) min = opt[i][j+1];
                if(i+1<m) min = (min==-1 ? opt[i+1][j] : Math.min(min, opt[i+1][j]));
                if(min!=-1) opt[i][j]+=min;
            }
        }
        return opt[0][0];
    }
}
```

## 85. Maximal Rectangle

### Description

### DP Solution - Memory Limit Exceeded

```
class Solution {
    private int[][][][] memo; // default to be -1, valid values: 0,1,2...
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0 || matrix[0].length==0) return 0;
        int rowLen = matrix.length;
        int colLen = matrix[0].length;
        // System.out.println("rowLen: "+ rowLen+", colLen: "+ colLen);
        memo = new int[rowLen][colLen][rowLen][colLen];
        initMemo();
        return maxRec(matrix, rowLen, colLen);
    }
    private int maxRec(char[][] matrix, int rowLen, int colLen){
        int max = 0;
        for(int i=0; i<rowLen; i++){
            for(int j=0; j<colLen; j++){
                for(int m=0; m<rowLen; m++){
                    for(int n=0; n<colLen; n++){
                        max = Math.max(max, opt(matrix, i, j, m, n));
                    }
                }
            }
        }
        return max;
    }
    private void initMemo(){
        for(int i=0; i<memo.length; i++){
            for(int j=0; j<memo[0].length; j++){
                for(int m=0; m<memo[0][0].length; m++){
                    for(int n=0; n<memo[0][0][0].length; n++){
                        memo[i][j][m][n] = -1;
                    }
                }
            }
        }
    }
    private int opt(char[][] matrix, int i, int j, int m, int n){
        if(memo[i][j][m][n]!=-1) return memo[i][j][m][n];
        if(i==m && j==n) return Integer.parseInt(""+matrix[i][j]);
        int ans = 0;
        // some can only fit horizontal cut, some only vertical cut, and some either works
        // for some that both work, choose one of two is okay
        if(i+1<=m){ // horizontal cut
            int a = opt(matrix, i+1, j, m, n); int b = opt(matrix, i, j, i, n);
            if(a==size(i+1, j, m, n) && b==size(i, j, i, n)) ans = a+b;
        }else if(j+1<=n){ // vertical cut
            int a = opt(matrix, i, j+1, m, n); int b = opt(matrix, i, j, m, j);
            if(a==size(i, j+1, m, n) && b==size(i, j, m, j)) ans = a+b;
        }
        memo[i][j][m][n] = ans;
        return ans;
    }
    private int size(int i, int j, int m, int n){
        return (m-i+1)*(n-j+1);
    }
}
```

Time: O(m^2 _ n^2)
Space: O(m^2 _ n^2)

### Solution - consecutive pre sum and histogram

1. Calculate consecutive pre sum for each row. For example, consecutive pre sum of `["1","0","1","1","1"]` is `[1,0,1,2,3]`.
2. Start from each point, go upward the column to get the max histogram. For example, column `[3,0,2,2,4]`, start from `i=4`:

i=4: 4*1(4-4+1=1) = 4
i=3: 2*2(4-3+1=2) = 4
i=2: 2\*3(4-2+1=3) = 6
i=1: break

So max area is 6.

```
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0) return 0;
        int[][] consecutivePreSum = new int[matrix.length][matrix[0].length];
        init(consecutivePreSum, matrix);
        int max = 0;
        for(int i=0; i<consecutivePreSum.length; i++){
            for(int j=0; j<consecutivePreSum[0].length; j++){
                if(consecutivePreSum[i][j]!=0) max = Math.max(max, histogram(i, j, consecutivePreSum));
            }
        }
        return max;
    }
    private int histogram(int i, int j, int[][] consecutivePreSum){
        int startI = i;
        int minWidth = consecutivePreSum[i][j];
        int maxArea = 0;
        while(i>=0){
            if(consecutivePreSum[i][j]>0){
                minWidth = Math.min(minWidth, consecutivePreSum[i][j]);
                maxArea = Math.max(maxArea, minWidth * (startI-i+1));
                i--;
            }else{
                break;
            }
        }
        return maxArea;
    }
    private void init(int[][] consecutivePreSum, char[][] matrix){
        for(int i=0; i<consecutivePreSum.length; i++){
            for(int j=0; j<consecutivePreSum[0].length; j++){
                if(matrix[i][j]=='1'){
                    if(j-1>=0)  consecutivePreSum[i][j] =  consecutivePreSum[i][j-1] + 1;
                    else        consecutivePreSum[i][j] = 1;
                }else{ // '0'
                     consecutivePreSum[i][j] = 0;
                }
            }
        }
    }


}
```

m is matrix.length, n is matrix[0].length

Time: O(m^2 * n)
Space: O(m*n)

### Final Solution - Stack

1. Calculate consecutive pre sum for each row. For example, consecutive pre sum of `["1","0","1","1","1"]` is `[1,0,1,2,3]`.
2. For each column, use stack to calculate the max histogram. For example, column `[3,0,4,2]`:
   A. push (-1, 0) into stack
   B. For `i=0`, 3>0, push 0(3) into stack
   C. For `i=1`, 0<3, pop 0(3) from stack, 3*1(1-1--1=1), push 1(0)
   D. For `i=2`, 4>0, push 2(4)
   E. For `i=3`, 2<4, pop 2(4), 4*1(3-1-1=1), push 3(2)
   F. `i=4`, i>=consecutivePreSum.length, pop 3(2), 2*2(4-1-1=2)
   G. `i=4`, i>=consecutivePreSum.length, pop 1(0), 0*4(4-1--1=4)

   max is 4.

   Stack:
   | 3(2)|
   | 2(4)|
   | 1(0)|
   | 0(3)|
   |-1(0)|

   ***

```
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0) return 0;
        int[][] consecutivePreSum = new int[matrix.length][matrix[0].length];
        init(consecutivePreSum, matrix);
        int max = 0;
        for(int j=0; j<consecutivePreSum[0].length; j++){
            max = Math.max(max, histogram(j, consecutivePreSum));
        }
        return max;
    }
    private int histogram(int j, int[][] consecutivePreSum){
        Stack<Status> s = new Stack<>();
        int i = 0;
        int max = 0;
        s.push(new Status(-1, 0));
        while(s.size()>1 || i<consecutivePreSum.length){
            if(i>=consecutivePreSum.length){
                Status pop = s.pop();
                max = Math.max(max, pop.val*(consecutivePreSum.length-1-s.peek().index));
                continue;
            }
            if(consecutivePreSum[i][j]>=s.peek().val){
                s.push(new Status(i, consecutivePreSum[i][j]));
                i++;
            }else{ // consecutivePreSum[i][j] is smaller, pop
                Status pop = s.pop();
                max = Math.max(max, pop.val*(i-1-s.peek().index));
            }
        }
        return max;
    }
    private void init(int[][] consecutivePreSum, char[][] matrix){
        for(int i=0; i<consecutivePreSum.length; i++){
            for(int j=0; j<consecutivePreSum[0].length; j++){
                if(matrix[i][j]=='1'){
                    if(j-1>=0)  consecutivePreSum[i][j] =  consecutivePreSum[i][j-1] + 1;
                    else        consecutivePreSum[i][j] = 1;
                }else{ // '0'
                     consecutivePreSum[i][j] = 0;
                }
            }
        }
    }
}
class Status{
    int index;
    int val;
    public Status(int index, int val){
        this.index = index;
        this.val = val;
    }
}
```

m is matrix.length, n is matrix[0].length

Time: O(m\*n)
Sapce: O(m)

## 221. Maximal Square

### Description

### Solution Brute Force

```
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max = 0;
        if(isAllZero(matrix)){
            return 0;
        }else{
            max = 1;
        }
        for(int i=0; i<matrix.length; i++){
            for(int j=0; j<matrix[0].length; j++){
                int maxPossibleLen = Math.min(matrix.length-i, matrix[0].length-j);
                if(matrix[i][j]=='1' && maxPossibleLen*maxPossibleLen>max){
                    int len=2;
                    while(len<=maxPossibleLen){
                        if(isSquareForLen2(i, j, len, matrix) || aroundAllOne(i, j, len, matrix)){
                            max = Math.max(max, len*len);
                            len++;
                        }else{
                            break;
                        }
                    }
                }
            }
        }
        return max;
    }
    private boolean isSquareForLen2(int i, int j, int len, char[][] matrix){
        return len==2 && matrix[i][j]=='1' && matrix[i+1][j]=='1' && matrix[i][j+1]=='1' && matrix[i+1][j+1]=='1';
    }
    private boolean isAllZero(char[][] matrix){
        for(int i=0; i<matrix.length; i++){
            for(int j=0; j<matrix[0].length; j++){
                if(matrix[i][j]=='1'){
                    return false;
                }
            }
        }
        return true;
    }
    private boolean aroundAllOne(int x, int y, int len, char[][] matrix){
        // right
        for(int j=y; j<y+len; j++){
            if(matrix[x][j]=='0') return false;
        }
        // down
        for(int i=x; i<x+len; i++){
            if(matrix[i][y+len-1]=='0') return false;
        }
        // left
        for(int j=y+len-1; j>=y; j--){
            if(matrix[x+len-1][j]=='0') return false;
        }
        // up
        for(int i=x+len-1; i>=x; i--){
            if(matrix[i][y]=='0') return false;
        }
        return true;
    }
}
```

## 87. Scramble String

### Description

```
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of s1 = "great":

    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t

To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".

    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t

We say that "rgeat" is a scrambled string of "great".

Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".

    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a

We say that "rgtae" is a scrambled string of "great".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

Example 1:

Input: s1 = "great", s2 = "rgeat"
Output: true

Example 2:

Input: s1 = "abcde", s2 = "caebd"
Output: false
```

### First Solution - String (TLE)

Take `rgtae` and `great` as example:

1. divide into 2 substring with i, if i=2, `rgtae.substring(0, 2)` is `rg`, for `great` it's `gr`
2. compare `rg` with `gr` recursively
3. compare left substring of s1 with right substring of s2(of the same sub length), for instance `tae` and `eat`, `t|ae ea|t`, compare `t` with `t`, compare `ae` with `ea`.
4. if length is 1, compare the character.

```
class Solution {
    public boolean isScramble(String s1, String s2) {
        if(s1.length()!=s2.length()) return false;
        int len = s1.length();
        if(len==1) return s1.charAt(0)==s2.charAt(0);
        for(int i=1; i<s1.length(); i++){
            if(isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i, len), s2.substring(i, len))) return true;
            if(isScramble(s1.substring(0, i), s2.substring(len-i, len)) && isScramble(s1.substring(i, len), s2.substring(0, len-i))) return true;
        }
        return false;
    }
}
```

This exceeds time, using DP Memorization is a good way to avoid duplicate computation.

### Improved Solution 1 - String

Add check in the begining to avoid TLE, to check if they have the same number of each letter. This assumes only 26 letters in s1 and s2.

```
class Solution {
    public boolean isScramble(String s1, String s2) {
        if(check(s1, s2)==false) return false;
        int len = s1.length();  // if length different, check will return false
        if(len==1) return s1.charAt(0)==s2.charAt(0);
        for(int i=1; i<s1.length(); i++){
            if(isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i, len), s2.substring(i, len))) return true;
            if(isScramble(s1.substring(0, i), s2.substring(len-i, len)) && isScramble(s1.substring(i, len), s2.substring(0, len-i))) return true;
        }
        return false;
    }
    private boolean check(String s1, String s2){
        int[] map = new int[26];
        for(int i=0; i<s1.length(); i++) map[s1.charAt(i)-'a']++;
        for(int i=0; i<s2.length(); i++) map[s2.charAt(i)-'a']--;
        for(int i=0; i<map.length; i++){
            if(map[i]!=0) return false;
        }
        return true;
    }
}
```

### Improved Solution 2(Final Solution) - DP Memorization

The Memorization I used for `String s1, String` is (str in alphabetical order, set of scrambles). It's TLE since sort String alphabetically add O(n) time complexity to each recursion.

Refactor `isScramble` from `String s1, String s2` to `String s1, int start1, int end1, String s2, int start2, int end2`, to `String s1, int start1, String s2, int start2, int len`.

So the `memo` is simply `(start1, start2, len)`.

The logic for `isScramble` is similiar.

1. divide into 2 parts with `subLen`.
2. compare left of s1 with left of s2(length is `subLen`), right of s1 with right s2(length is `len-subLen`). If true then return true.
3. compare left of s1 with right of s2(length is `subLen`), right of s1 with left of s2(length is `len-subLen`). If true then return true.
4. If length is 1, simply compare character.

```
class Solution {
    private int[][][] memo; // 0 is default, 1 is true, -1 is false
    public boolean isScramble(String s1, String s2) {
        if(s1.length()!=s2.length()) return false;
        int wordLen = s1.length();
        memo = new int[wordLen][wordLen][wordLen+1]; // (start1, start2, len)
        return isScramble(s1, 0, s2, 0, wordLen);
    }
    private boolean isScramble(String s1, int start1, String s2, int start2, int len) {
        if(len==1) return s1.charAt(start1)==s2.charAt(start2);
        if(memo[start1][start2][len]!=0) return memo[start1][start2][len]==1?true:false;
        boolean ans = false;
        for(int subLen = 1; subLen<len; subLen++){
            if(isScramble(s1, start1, s2, start2, subLen) && isScramble(s1, start1+subLen, s2, start2+subLen, len-subLen)){
                ans = true;
                break;
            }
            if(isScramble(s1, start1, s2, start2+len-subLen, subLen) && isScramble(s1, start1+subLen, s2, start2, len-subLen)){
                ans = true;
                break;
            }
        }
        memo[start1][start2][len] = ans==true?1:-1;
        return ans;
    }
}
```

## 91. Decode Ways

### First Solution DP + Memorization (2D)

1. cur-start==0. If cur points to `0`, count+=0. Otherwise, there can be 2 possiblities.
   A. cut
   B. If the number of cur and next <= 26, not cut now
2. cur-start==1: must cut.

And use `int[][] memo` to do memorization to save duplciate computation.

```
class Solution {
    private int[][] memo; // default is -1
    public int numDecodings(String s) {
        memo = new int[s.length()][s.length()]; // start, cur => numDecodings
        for(int i=0; i<memo.length; i++){
            for(int j=0; j<memo[0].length; j++) memo[i][j] = -1;
        }
        if(s.length()==0) return 0;
        return numDecodings(s, 0, 0);
    }
    public int numDecodings(String s, int start, int cur) {
        if(cur>=s.length()) return 1;
        if(memo[start][cur]!=-1) return memo[start][cur];
        int count = 0;
        if(cur-start==0){
            if(s.charAt(cur)!='0'){
                count += numDecodings(s, cur+1, cur+1); // cut
                if(cur+2<=s.length() && Integer.parseInt(s.substring(cur, cur+2))<=26){
                    count += numDecodings(s, cur, cur+1); // not cut
                }
            }
        }else if(cur-start==1){ // must cut
            count += numDecodings(s, cur+1, cur+1);
        }
        memo[start][cur] = count;
        return count;
    }
}
```

### Final Solution

opt(i) is number of ways to decode String (s_i s_i+1 ... s_len-1)

```
class Solution {
    public int numDecodings(String s) {
        int[] opt = new int[s.length()+1]; // opt(i) is number of ways to decode String s_i s_i+1 ... s_len-1
        opt[s.length()] = 1; // cut and decoded finished, this is one valid way
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)=='0') opt[i] = 0;
            else{
                // i+1: decode [si], all after i is in doubt.
                // i+2: decode [s_i s_i+1], all after i+1 is in doubt.
                if(i+2<opt.length&&Integer.parseInt(s.substring(i, i+2))<=26) opt[i] = opt[i+1]+opt[i+2];
                else opt[i] = opt[i+1];
            }
        }
        return opt[0];
    }
}
```

## 120. Triangle

### Description

```
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:

Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
```

### First Solution 2D DP

opt(i, j) is the minimum path sum from 0th row to ith row and select j in ith row.

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int rowLen = triangle.size();
        if(rowLen==0) return 0;
        int maxColLen = triangle.get(rowLen-1).size();
        int[][] opt = new int[rowLen][maxColLen];
        opt[0][0] = triangle.get(0).get(0);
        for(int i=1; i<rowLen; i++){
            for(int j=0; j<triangle.get(i).size(); j++){
                int val = triangle.get(i).get(j);
                boolean jExist = j<triangle.get(i-1).size();
                boolean preJExist = j-1>=0;
                if(jExist && preJExist) opt[i][j] = val + Math.min(opt[i-1][j], opt[i-1][j-1]);
                if(jExist && !preJExist) opt[i][j] = val + opt[i-1][j];
                if(!jExist && preJExist) opt[i][j] = val + opt[i-1][j-1];
                // the case j and j-1 both not exist won't happen
            }
        }
        int min = opt[maxColLen-1][0];
        for(int j=0; j<maxColLen; j++){
            min = Math.min(min, opt[rowLen-1][j]);

        }
        return min;
    }
}
```

### Improve from 2D to 1D DP (Final Solution)

opt(j) is the min path sum for column j.

There are three statements using opt. And everytime I actually use `i-1` to compute i's opt. So I can easily get rid of `i-1` and adjust to `j--` to make sure `opt(j-1)` for this `i` is computed after computing `opt(j)`, since sometimes I use `opt[i-1][j-1]` to compute `opt[i][j]`.

From:

```
if(jExist && preJExist) opt[i][j] = val + Math.min(opt[i-1][j], opt[i-1][j-1]);
if(jExist && !preJExist) opt[i][j] = val + opt[i-1][j];
if(!jExist && preJExist) opt[i][j] = val + opt[i-1][j-1];
```

To:

```
if(jExist && preJExist) opt[j] = val + Math.min(opt[j], opt[j-1]);
if(jExist && !preJExist) opt[j] = val + opt[j];
if(!jExist && preJExist) opt[j] = val + opt[j-1];
```

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int rowLen = triangle.size();
        if(rowLen==0) return 0;
        int maxColLen = triangle.get(rowLen-1).size();
        int[] opt = new int[maxColLen];
        opt[0] = triangle.get(0).get(0);
        for(int i=1; i<rowLen; i++){
            // if j from 0 to len-1 then opt[j] will use opt[j-1], which has been updated before
            for(int j=triangle.get(i).size()-1; j>=0; j--){
                int val = triangle.get(i).get(j);
                boolean jExist = j<triangle.get(i-1).size();
                boolean preJExist = j-1>=0;
                if(jExist && preJExist) opt[j] = val + Math.min(opt[j], opt[j-1]);
                if(jExist && !preJExist) opt[j] = val + opt[j];
                if(!jExist && preJExist) opt[j] = val + opt[j-1];
                // the case j and j-1 both not exist won't happen
            }
        }
        int min = opt[0];
        for(int j=1; j<maxColLen; j++){
            min = Math.min(min, opt[j]);

        }
        return min;
    }
}
```

## 139. Word Break

### Description

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

### Final Solution (DP+Memorization)

1. Find the words that match with the prefix of s.
2. Call `wordBreak` recursively with each `s.substring(w.length())`, either return true then true
3. End condition: if finally s is empty, then it shows just used up. Otherwise I cannot find match words and return false after for loop.
4. Use memo to memorize (substring, can be nicely segmented or not)

```
class Solution {
    private Map<String, Boolean> memo = new HashMap<>(); // (string, can be nicely segmented or not)
    public boolean wordBreak(String s, List<String> wordDict) {
        if(s.length()==0) return true;
        if(memo.get(s)!=null) return memo.get(s);
        List<String> words = getMatchWords(s, wordDict);
        boolean ans = false;
        for(String w: words){
            if(wordBreak(s.substring(w.length()), wordDict)==true){
                ans = true;
                break;
            }
        }
        memo.put(s, ans);
        return ans;
    }
    private List<String> getMatchWords(String s, List<String> wordDict){
        List<String> ans = new ArrayList<>();
        for(String w: wordDict){
            if(s.startsWith(w)) ans.add(w);
        }
        return ans;
    }
}
```

Hard to calculate time complexity and space complexity.

### Bonus: DP Solution

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // opt(i) is whether s0 s1 ... si can be segmented.
        boolean[] opt = new boolean[s.length()];
        Set<String> wordSet = new HashSet<>(wordDict);
        for(String w: wordSet){
            if(w.length() <= s.length() && s.substring(0, w.length()).equals(w)) opt[w.length()-1] = true;
        }
        for(int i=0; i<s.length(); i++){
            for(int j=0; j<i; j++){
                if(opt[j] && wordSet.contains(s.substring(j+1, i+1))){
                    opt[i] = true;
                    break;
                }
            }
        }
        return opt[s.length()-1];
    }
}
```

### Bonus: Improved DP Solution

opt(i) is whether s_0 s_1 ... s_i-1 can be segmented. Leave out opt[0] to set to true and start the compare. `opt[i]=opt[j] && wordSet.contains(s.substring(j+1, i+1))`

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // opt(i) is whether s_0 s_1 ... s_i-1 can be segmented.
        boolean[] opt = new boolean[s.length()+1];
        Set<String> wordSet = new HashSet<>(wordDict);
        opt[0] = true; // s_-1 can be segmented, no meaning, just to start the compare
        for(int i=1; i<=s.length(); i++){
            for(int j=0; j<i; j++){
                if(opt[j] && wordSet.contains(s.substring(j, i))){
                    opt[i] = true;
                    break;
                }
            }
        }
        return opt[s.length()];
    }
}
```

Time: O(n^3)
Space: O(n)

## 140. Word Break II

### Description

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]
Example 2:

Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.
Example 3:

Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]
```

### Final Solution

1. find matched words
2. for each w, call `recursion(s.substring(w.length()))` to get `List<StringBuilder>`, for each sb in list, insert w and space to begining of sb. combine all lists into one and return.
3. Use memo to memorize (str, list of possible sentence(list of sb)), be carefully to deepClone list of StringBuilder when put into memo and get from memo to avoid changes on StringBuilder update sb in memo.

```
class Solution {
    private Map<String, List<StringBuilder>> memo = new HashMap<>(); // (str, list of possible sentence)
    public List<String> wordBreak(String s, List<String> wordDict) {
        List<StringBuilder> l = recursion(s, wordDict);
        List<String> ans = new ArrayList<>();
        for(StringBuilder sb: l){
            ans.add(sb.substring(1));
        }
        return ans;
    }
    public List<StringBuilder> recursion(String s, List<String> wordDict) {
        if(s.length()==0) return new ArrayList<StringBuilder>(){{add(new StringBuilder());}};
        // must use deepClone, since the sb in returned res will be inserted and update that in memo
        if(memo.get(s)!=null) return deepClone(memo.get(s));
        List<StringBuilder> ans = new ArrayList<>();
        List<String> words = getMatchWords(s, wordDict);
        for(String w: words){
            List<StringBuilder> res = recursion(s.substring(w.length()), wordDict);
            for(StringBuilder sb: res){
                sb.insert(0, w); sb.insert(0, " ");
            }
            ans.addAll(res);
        }
        // must use deepClone, since the ans will be inserted and update that in memo
        memo.put(s, deepClone(ans));
        return ans;
    }
    private List<StringBuilder> deepClone(List<StringBuilder> l){
        List<StringBuilder> copy = new ArrayList<>();
        for(StringBuilder sb: l){
            copy.add(new StringBuilder(sb));
        }
        return copy;
    }
    private List<String> getMatchWords(String s, List<String> wordDict){
        List<String> ans = new ArrayList<>();
        for(String w: wordDict){
            if(s.startsWith(w)) ans.add(w);
        }
        return ans;
    }
}
```

Time and space complexity? Have to read docs or watch videos for the analysis for DP memorization. Or transfer to DP to analyze the time complexity?

Time: O(n^3). Convert to DP.

```
size(i) from 1 to s.length
    start(j) from 0 to s.length-i
        sub = s[j, i]
        opt(i) = each one in opt(j) + sub, if wSet contains sub
```

i is O(n), j is O(n), `s[j, i]` is O(n), each one in opt(j) is O(n), so O(n^3)

Space: O(n^3). key is O(n), list of String is O(n^2).

## 152. Maximum Product Subarray

### Description

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

### First Solution MLE

opt(i, j) is the product from nums[i](inclusive) to nums[j](exclusive).

```
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length==0) return 0;
        int[][] opt = new int[nums.length][nums.length+1];
        for(int i=0; i<nums.length; i++) opt[i][i] = 1;
        int max = nums[0];
        for(int i=0; i<nums.length; i++){
            for(int j=i+1; j<=nums.length; j++){
                opt[i][j] = opt[i][j-1] * nums[j-1];
                max = Math.max(max, opt[i][j]);
            }
        }
        return max;
    }
}
```

Time: O(n^2)
Space: O(n^2)

### Final Solution (DP + minmax)

`opt[i][0]` is the minimum product of subarray from index 0 to i(inclusive), `opt[i][1]` is the maximum product of subarray from index 0 to i(inclusive).

MINMAX: `negative i-1 min` _ `negtive nums[i]` > `positive i-1 max` _ `negative nums[i]`.

If min of `i-1` is minus, and `nums[i]` is also minus, then product will be positive number, it's larger than positive\*negtive, even positive is max for `i-1`

For example, [1,-2,3,-4]

Only remember max: 1, -2, 3, -4, max is 3

Remember max and min: (1,1),(-2,-2),(-6,3),(-12,24), max is 24

```
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length==0) return 0;
        // opt[i][0] is the min product of subarray ending in index i, 1 stands for max
        int[][] opt = new int[nums.length][2];
        for(int i=0; i<nums.length; i++){
            if(i-1>=0){
                opt[i][0] = min(nums[i], opt[i-1][0]*nums[i], opt[i-1][1]*nums[i]);
                opt[i][1] = max(nums[i], opt[i-1][0]*nums[i], opt[i-1][1]*nums[i]);
            }else{
                opt[i][0] = nums[i];
                opt[i][1] = nums[i];
            }
        }
        int max = nums[0];
        for(int i=0; i<opt.length; i++){
            max = Math.max(max, opt[i][1]);
        }
        return max;
    }
    private int max(int a, int b, int c){
        return Math.max(a, Math.max(b, c));
    }
    private int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
}
```

Time: O(n)
Space: O(n)

## 213. House Robber II

### Description

```
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
Example 2:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.

```

### Final Solution - DP

opt(i, j) is the maximum amount of money robbed one night for house 0 to house i, j==1 means last house is robbed, j==0 means last house isn't robbed.

opt(i, j) = max(
opt(i-2, j) + nums[i] // rob i
opt(i-1, j) // not rob i
)

If i==0,
opt(0, 1) = 0 // last is robbed and adjacent to first one, so first one cannot be robbed
opt(0, 0) = nums[0] // last one is not robbed, so must rob first one to maximize money

If i==len-1
opt(i, 0) = opt(i-1, 0) // not rob last one(i)
opt(i, 1) = opt(i-2, 1) + nums[i] // rob last one

return max{opt(len-1, 0), opt(len-1, 1)}

Only when len>=3 then the statement `opt[i][1] = opt[i-2][1] + nums[i]` where i is len-1 can work. So I have to deal with cases when len is 0, 1, 2 separately.

```
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len==0) return 0;
        if(len==1) return nums[0];
        if(len==2) return Math.max(nums[0], nums[1]);
        int[][] opt = new int[len][2];
        opt[0][0] = nums[0];
        opt[0][1] = 0;
        for(int j=0; j<=1; j++) opt[1][j] = Math.max(nums[1], opt[0][j]);
        int i=2;
        for(; i<len-1; i++){
            for(int j=0; j<=1; j++){
                opt[i][j] = Math.max(opt[i-2][j]+nums[i], opt[i-1][j]);
            }
        }
        // i is len-1
        opt[i][0] = opt[i-1][0];
        opt[i][1] = opt[i-2][1] + nums[i];
        return Math.max(opt[i][0], opt[i][1]);
    }
}
```

Time: O(n)
Space: O(n)

## 264. Ugly Number II

### Description

Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example:

Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note:

1 is typically treated as an ugly number.
n does not exceed 1690.

### First Solution DP+Map - TLE

Use map because I don't know how many times final (i-1)/n can be, previously I used 2\*n but exceeds.

opt(i) = opt(i/2) if i%2==0
= opt(i/3) if i%3==0
= opt(i/5) if i%5==0
= (i==1) o.w.

```
class Solution {
    public int nthUglyNumber(int n) {
        if(n==0) return 0;
        Map<Integer, Boolean> opt = new HashMap<>(); // (i, is ugly number or not)
        int i=1;
        int count=0;
        while(count<n){
            if(isUglyNumber(i, opt)){
                count++;
            }
            i++;
        }
        return i-1;
    }
    private boolean isUglyNumber(int i, Map<Integer, Boolean> opt){
        if(i%2==0){
            opt.put(i, opt.get(i/2));
        }else if(i%3==0){
            opt.put(i, opt.get(i/3));
        }else if(i%5==0){
            opt.put(i, opt.get(i/5));
        }else{
            opt.put(i, i==1);
        }
        return opt.get(i);
    }
}
```

### Final Solution - pre compute + 3 pointers + DP

Use static to pre compute result for each possible input n since `n<=1690`.

opt(n) is the nth ugly number.

```
opt(n) = min(opt(i2)*2, opt(i3)*3, opt(i5)*5)
```

If used `ix`, then `ix++`.

I used opt(i2) instead of i2 becuase i2 cannot be numbers like 7, so it must use ugly number from small to big.

```
// 3 pointers
class Solution {
    private static int[] opt = preCompute();
    private static int[] preCompute(){
        int[] opt = new int[1691];
        opt[1] = 1;
        int n = 2;
        int i2 = 1;
        int i3 = 1;
        int i5 = 1;
        while(n<opt.length){
            // use opt[i] because idx cannot be number like 7, must use valid number, which is all in opt
            opt[n] = min(opt[i2]*2, opt[i3]*3, opt[i5]*5);
            if(opt[n]==opt[i2]*2) i2++;
            if(opt[n]==opt[i3]*3) i3++;
            if(opt[n]==opt[i5]*5) i5++;
            n++;
        }
        return opt;
    }
    private static int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
    public int nthUglyNumber(int n) {
        return opt[n];
    }
}
```

## 300. Longest Increasing Subsequence

### Description

```
Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:

Input: [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Note:

There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
Follow up: Could you improve it to O(n log n) time complexity?
```

### First Solution DP

opt(i) is the length of longest increasing subsequence(LIS) ending in index i.
, starting from anywhere before i.

opt(i) is at least its character in subsequence, so init every opt(i) to be 1.

```
if opt(i) > opt(j): (0<=j<i)
    opt(i) = 1 + max(opt(j))
```

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length==0) return 0;
        int[] opt = new int[nums.length];
        init(opt);
        for(int i=0; i<nums.length; i++){
            for(int j=0; j<i; j++){
                if(nums[i]>nums[j]) opt[i] = Math.max(opt[i], 1+opt[j]);
            }
        }
        return max(opt);
    }
    private int max(int[] opt){
        int ans = 0;
        for(int n: opt){
            ans = Math.max(ans, n);
        }
        return ans;
    }
    private void init(int[] opt){
        for(int i=0; i<opt.length; i++){
            opt[i] = 1;
        }
    }
}
```

Time: O(n^2)
Space: O(n)

### Final Solution Greedy+binary search (follow up)

Find out the index to insert by `Arrays.binarySearch`, if it's negative I have to use `j=-j-1` to update to right index, and update `arr[j]` with `nums[i]`. If update index exceeds `len`, `len++`.

For example, `[10,9,2,5,3,7,101,18]`

[10][9]
[2][2, 5]
[2, 3][2, 3, 7]
[2, 3, 7, 101][2, 3, 7, 18]

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length==0) return 0;
        int[] arr = new int[nums.length]; // max is nums.length if nums is asc
        int len = 0;
        for(int i=0; i<nums.length; i++){
            int j = Arrays.binarySearch(arr, 0, len, nums[i]);
            if(j<0) j = -j-1;
            arr[j] = nums[i];
            if(j>len-1) len++;
        }
        return len;
    }
}
```

Time: O(nlogn)
Space: O(n)

## Similar to 300: 334. Increasing Triplet Subsequence

### Description

```
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

Formally the function should:

Return true if there exists i, j, k
such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false.
Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.

Example 1:

Input: [1,2,3,4,5]
Output: true
Example 2:

Input: [5,4,3,2,1]
Output: false
```

### Final Solution small and big var

Have 2 variables small and big, set to max. Walk through nums:

1. if n<= small: small = n
2. else if n<=big: big = n
3. else: return true
4. if for ends, return false

Have to first set small to be non max, then big, then go to else. This makes sure `i<j<k`. And going to else if and else makes sure `small<big<n`, then it meets condition and finds the triplet so return true.

```
class Solution {
    public boolean increasingTriplet(int[] nums) {
        if(nums.length<3) return false;
        int small = Integer.MAX_VALUE;
        int big = Integer.MAX_VALUE;
        for(int n: nums){
            if(n<=small){
                small = n;
            }else if(n<=big){ // small < n <= big
                big = n;
            }else{ // n > big
                return true; // n>big>small, first find small, then big, update them to be non max, so I can find one in else, so meets the condition
            }
        }
        return false;
    }
}
```

## 304. Range Sum Query 2D - Immutable

### Description

```
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

Example:

Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12

Note:

    You may assume that the matrix does not change.
    There are many calls to sumRegion function.
    You may assume that row1 ≤ row2 and col1 ≤ col2.
```

### First Solution

```
class NumMatrix {
    private int[][] matrix;
    private int[][][][] memo;
    public NumMatrix(int[][] matrix) {
        this.matrix = matrix;
        int rowLen = matrix.length;
        int colLen = matrix[0].length;
        this.memo = new int[rowLen][colLen][rowLen][colLen];
        for(int i=0; i<rowLen; i++){
            for(int j=0; j<colLen; j++){
                for(int x=0; x<rowLen; x++){
                    for(int y=0; y<colLen; y++){
                        memo[i][j][x][y] = -1;
                    }
                }
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        if(memo[row1][col1][row2][col2]!=-1) return memo[row1][col1][row2][col2];
        int sum = 0;
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                sum += matrix[i][j];
            }
        }
        memo[row1][col1][row2][col2] = sum;
        return sum;
    }
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
```

m is the number of rows and n is the number of columns.

Time: O(m*n)

Space: O(m^2 * n^2)

### Final Solution - DP + presum

```
For every row, calculate the presum from col 0 to current col.

In sumRegion, use presum[i][col2]-presum[i][col1-1] or presum[i][col2] if col1==0 and add up for every row.

class NumMatrix {
    int[][] presum; // in every row, calculate the presum
    public NumMatrix(int[][] matrix) {
        if(matrix.length!=0){
            presum = new int[matrix.length][matrix[0].length];
            for(int i=0; i<matrix.length; i++){
                for(int j=0; j<matrix[0].length; j++){
                    if(j==0)    presum[i][j] = matrix[i][j];
                    else        presum[i][j] = presum[i][j-1] + matrix[i][j];
                }
            }
        }
    }
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int sum = 0;
        for(int i=row1; i<=row2; i++){
            if(col1-1>=0)   sum += (presum[i][col2]-presum[i][col1-1]);
            else            sum += presum[i][col2];
        }
        return sum;
    }
}
```

m is the number of rows and n is the number of columns.

Time: O(m)

Space: O(m*n)

## 308. Range Sum Query 2D - Mutable

### Description

```
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

Example:

Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
update(3, 2, 2)
sumRegion(2, 1, 4, 3) -> 10

Note:

    The matrix is only modifiable by the update function.
    You may assume the number of calls to update and sumRegion function is distributed evenly.
    You may assume that row1 ≤ row2 and col1 ≤ col2.
```

### Final Solution - DP+presum+update presum

Same logic of NumMatrix and update as 304. When update a value, get prevVal by presum, simply update from current col to the end of this row, with val-preVal.

```
class NumMatrix {
    private int[][] presum;
    public NumMatrix(int[][] matrix) {
        if(matrix.length!=0){
            presum = new int[matrix.length][matrix[0].length];
            for(int i=0; i<matrix.length; i++){
                for(int j=0; j<matrix[0].length; j++){
                    if(j==0)    presum[i][j] = matrix[i][j];
                    else        presum[i][j] = presum[i][j-1]+matrix[i][j];
                }
            }        
        }
    }
    public void update(int row, int col, int val) {
        int preVal = (col==0? presum[row][col]:presum[row][col]-presum[row][col-1]);
        for(int j=col; j<presum[0].length; j++){
            presum[row][j] += (val-preVal);
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int sum = 0;
        for(int i=row1; i<=row2; i++){
            if(col1==0) sum += presum[i][col2];
            else        sum += (presum[i][col2]-presum[i][col1-1]);
        }
        return sum;
    }
}
/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * obj.update(row,col,val);
 * int param_2 = obj.sumRegion(row1,col1,row2,col2);
 */
```

m is the number of rows and n is the number of columns.

update time: O(n)

sumRegion time: O(m)

Space: O(m*n)

## 309. Best Time to Buy and Sell Stock with Cooldown

### Description

```
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:

Input: [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]

```

### First Solution - DP

opt(i, j) is the max profix from day 0 to day i after transaction.

First digit is whether hold stock after transaction.
Second is whether cooled down after transaction.

j==0(00): not hold stock and not cooled down after transaction.
j==1(01): not hold stock and cooled down after transaction
j==2(10): hold stock and not cooled down after transaction. This case won't EXIST.
j==3(11): hold stock and cooled down after transaction

```
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int[][] opt = new int[prices.length][4];
        opt[0][0]=Integer.MIN_VALUE/2;
        opt[0][1]=0;
        opt[0][3]=-prices[0];

        for(int i=1; i<prices.length; i++){
            opt[i][0] = opt[i-1][3]+prices[i];
            opt[i][1] = Math.max(opt[i-1][0], opt[i-1][1]);
            opt[i][3] = Math.max(-prices[i]+opt[i-1][1], opt[i-1][3]);
        }
        return Math.max(Math.max(opt[prices.length-1][0], opt[prices.length-1][1]), opt[prices.length-1][3]);
    }
}
```

### Improved Solution (Final)

Since the fomula always goes from `i-1` to `i`, then just use three variables to replace the `opt` array.

DP improved. 3 variables: `notHoldNotCool`(sell today), `notHoldCool`(nothing today), `holdCool`(buy or nothing today). Walk through every day and return max of three variables.

```
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int notHoldNotCool =Integer.MIN_VALUE/2;
        int notHoldCool =0;
        int holdCool =-prices[0];
        for(int i=1; i<prices.length; i++){
            int tmp = notHoldCool;
            notHoldCool = Math.max(notHoldNotCool, notHoldCool); // do nothing today
            notHoldNotCool = holdCool+prices[i]; // sell today
            holdCool = Math.max(-prices[i]+tmp, holdCool); // buy today or do nothing
        }
        return Math.max(Math.max(notHoldNotCool, notHoldCool), holdCool); // max of all possibilities
    }
}
```

## 322. Coin Change

### Description

```
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
Note:
You may assume that you have an infinite number of each kind of coin.
```

### First Solution DP+memorization 2D

```
class Solution {
    private int[][] memo;
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        memo = new int[coins.length][amount+1];
        return coinNumber(coins, coins.length-1, amount, 0);
    }
    private int coinNumber(int[] coins, int i, int amount, int coinNum){
        if(amount==0) return coinNum;
        if(i<0) return -1;
        if(memo[i][amount]!=0) return memo[i][amount]==-1?-1:memo[i][amount]+coinNum;
        int ans = Integer.MAX_VALUE;
        for(int n=0; n*coins[i]<=amount; n++){
            int tmp = coinNumber(coins, i-1, amount-n*coins[i], coinNum+n);
            if(tmp>=0 && tmp<ans) ans = tmp;
        }
        memo[i][amount] = ans==Integer.MAX_VALUE?-1:(ans-coinNum);
        return ans==Integer.MAX_VALUE?-1:ans;
    }
}
```

n is coins.length, m==amount.

Time: O(n*m * m). For every cell, the worst case for loop is when `coins[i]` is 1, then it's m times. So O(m) for each cell.

Space: O(n\*m)

### Final Solution - DP+Memorization (1D)

Substract each kind of coin from amount and get min number of coins for this amount. Then the only param is `amount`.

`coinNumber(amount)` is the minimum number of coins for the amount.

```
class Solution {
    private int[] memo;
    public int coinChange(int[] coins, int amount) {
        memo = new int[amount+1];
        return coinNumber(coins, amount);
    }
    private int coinNumber(int[] coins, int amount){
        if(memo[amount]!=0) return memo[amount];
        if(amount==0) return 0;
        int min = -1;
        for(int i=0; i<coins.length; i++){
            if(amount-coins[i]>=0){
                int tmp = coinNumber(coins, amount-coins[i]);
                if(tmp!=-1){
                    if(min==-1 || tmp<min) min = tmp;
                }
            }
        }
        int ans = min==-1?-1:min+1;
        memo[amount] = ans;
        return ans;
    }

}
```

n is coins.length, m==amount.

Time: O(m\*n). As for each cell, the time is for loop, which is O(n)
Space: O(m)

## 983. Minimum Cost For Tickets

### Description

```
In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.

Train tickets are sold in 3 different ways:

a 1-day pass is sold for costs[0] dollars;
a 7-day pass is sold for costs[1] dollars;
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.

Return the minimum number of dollars you need to travel every day in the given list of days.



Example 1:

Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation:
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total you spent $11 and covered all the days of your travel.
Example 2:

Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation:
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total you spent $17 and covered all the days of your travel.


Note:

1 <= days.length <= 365
1 <= days[i] <= 365
days is in strictly increasing order.
costs.length == 3
1 <= costs[i] <= 1000

```

### Final Solution

Assume a ticket bought in day d is valid for (d-len, d], this gives the same result if a ticket bought in day d is valid for [d, d+len). `len` can be 1 or 7 or 30.

`opt(d, j)` is the minimum amount of money spent for day 0 to day d if I buy jth ticket for day d.

```
opt(d, j) =
    if j==0: min{ opt(d-1, 0/1/2) } + c(0)
    if j==1: min{ opt(d-7, 0/1/2) } + c(1)
    if j==2: min{ opt(d-30, 0/1/2) } + c(2)
```

In a word:

```
opt(d, j) = min{ opt(d-len, all possible j) } + c(j)
```

If `d-len < 0`, `opt(d, j) = c(j)`

If `d` not in list of days, `opt(d, j) = opt(d-1, j)`

```
class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        if(days.length==0) return 0;
        int maxDay = 0;
        for(int d: days) maxDay = Math.max(maxDay, d);
        int[][] opt = new int[maxDay+1][costs.length];
        for(int d=0, idx=0; d<=maxDay; d++){
            if(days[idx]==d){
                if(d-1>=0)  opt[d][0] = min(opt[d-1][0], opt[d-1][1], opt[d-1][2])+costs[0];
                else        opt[d][0] = costs[0];
                if(d-7>=0)  opt[d][1] = min(opt[d-7][0], opt[d-7][1], opt[d-7][2])+costs[1];
                else        opt[d][1] = costs[1];
                if(d-30>=0) opt[d][2] = min(opt[d-30][0], opt[d-30][1], opt[d-30][2])+costs[2];
                else        opt[d][2] = costs[2];
                idx++;
            }else if(d-1>=0){
                for(int j=0; j<=2; j++){
                    opt[d][j] = opt[d-1][j];
                }
            }
        }
        return min(opt[maxDay][0], opt[maxDay][1], opt[maxDay][2]);
    }
    private int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
}
```

N is max day, since `1 <= days[i] <= 365`, N is 365 at most.

Time: O(N)
Space: O(N)

## 343. Integer Break

### Description

```
Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

Example 1:

Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
Example 2:

Input: 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
Note: You may assume that n is not less than 2 and not larger than 58.
```

### Final Solution - DP

`opt(i)` is the maximum product for number i.

Break i into `i-j` and `j`, use bigger one of `i-j` itself, or the break up of `i-j`, which is `opt(i-j)`. Same applies to `j`.

```
opt(i) = max{
    opt(i-j)/(i-j) * opt(j)/j (4 combinations)
}

j from 1 to i-1
```

```
class Solution {
    public int integerBreak(int n) {
        int[] opt = new int[n+1];
        for(int i=2; i<=n; i++){
            int max = 0;
            for(int j=1; j<=i-1; j++){
                max = max(max, opt[i-j]*opt[j], (i-j)*opt[j], opt[i-j]*j, (i-j)*j);
            }
            opt[i] = max;
        }
        return opt[n];
    }
    private int max(int... nums){
        int ans = 0;
        for(int n: nums) ans = Math.max(ans, n);
        return ans;
    }
}
```

Time: O(n^2)
Space: O(n)

## 351. Android Unlock Patterns

### Description

https://leetcode.com/problems/android-unlock-patterns/

### Final Solution - DFS + Backtracking + Symmetric

Use dfs to try every number and send the rest into dfs.

Use `dfs(boolean[] selected, int prev, int remain)`. `boolean[] selected` is used to remember selected keys, and the length is fixed to be 10. Set true before `dfs` and set back to false afterwards. `prev` is previous selected key. `remain` is the remaining length of password.

Use backtracking to stop when it's not possible to e valid password, if prev key and current key is not valid, stop halfway, if goes to remain==0, then return 1.

Use symmetric to save some computation. Password starting with 1, 3, 7, 9, since they are symmetric, their number of possible passwords are the same. This also applies to 2, 4, 6, 8. So just calculate one time and multiply 4.

To remember the key that is passed through between two keys, use an array. For example, `passKeyMap[1][3]=passKeyMap[3][1]=2`, 2 is the key passed through by `13` and `31`.

```
class Solution {
    int[][] passKeyMap = new int[10][10]; // 0 means no pass through key, ow is the number of pass through key
    public Solution(){
        passKeyMap[1][3]=passKeyMap[3][1]=2;
        passKeyMap[4][6]=passKeyMap[6][4]=passKeyMap[2][8]=passKeyMap[8][2]=passKeyMap[1][9]=passKeyMap[9][1]=passKeyMap[3][7]=passKeyMap[7][3]=5;
        passKeyMap[7][9]=passKeyMap[9][7]=8;
        passKeyMap[1][7]=passKeyMap[7][1]=4;
        passKeyMap[3][9]=passKeyMap[9][3]=6;
    }
    public int numberOfPatterns(int m, int n) {
        int ans = 0;
        for(int i=m; i<=n; i++) ans+=numberOfPatterns(i);
        return ans;
    }
    private int numberOfPatterns(int n){
        boolean[] selected = new boolean[10];
        int count = 0;
        // 1, 3, 7, 9
        selected[1] = true;
        count += (4 * dfs(selected, 1, n-1));
        selected[1] = false;
        // 2, 4, 6, 8
        selected[2] = true;
        count += (4 * dfs(selected, 2, n-1));
        selected[2] = false;
        // 5
        selected[5] = true;
        count += dfs(selected, 5, n-1);
        return count;
    }
    private int dfs(boolean[] selected, int prev, int remain){
        if(remain==0) return 1;
        int count = 0;
        for(int i=1; i<=9; i++){
            if(selected[i]==true) continue;
            if(valid(prev, i, selected)==false) continue;
            selected[i] = true;
            count += dfs(selected, i, remain-1);
            selected[i] = false;
        }
        return count;
    }
    private boolean valid(int a, int b, boolean[] selected){
        int pass = passKeyMap[a][b];
        // if a and b are adjacent(no pass) or the pass through key has been selected before => valid
        if(pass==0 || selected[pass]==true) return true;
        else                                return false;
    }
}
```

## 357. Count Numbers with Unique Digits

### Description

```
Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.

Example:

Input: 2
Output: 91
Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,
             excluding 11,22,33,44,55,66,77,88,99
```

### First Solution - DFS + DP(Symmetric)

1. get count of number with distinct digits, have a boolean[] selected to store selected and used digit, use dfs to walk through left ones. `dfs(boolean[] selected, int remain)`.
2. When 2 digits used and 2 remains, no matter which 2 valid digit are selected, they get the same count of number with distinct digits.

```
class Solution {
    private int[][] memo; // (number of selected digit, remain)
    public int countNumbersWithUniqueDigits(int n) {
        memo = new int[10][n];
        int ans = 0;
        boolean[] selected = new boolean[10];
        selected[1] = true;
        for(int len=1; len<=n; len++){
            // start with 1 has same result as 2/.../9, cannot start with 0 so 0 excluded
            ans+= 9 * dfs(selected, len-1);
        }
        return ans+1;
    }
    // return count of number with distinct digits
    private int dfs(boolean[] selected, int remain){
        if(remain==0) return 1;
        int selectedNum = numOfSelected(selected);
        if(memo[selectedNum][remain]!=0) return memo[selectedNum][remain];
        int count = 0;
        for(int i=0; i<=9; i++){
            if(selected[i]==true) continue;
            selected[i] = true;
            count += dfs(selected, remain-1);
            selected[i] = false;
        }
        memo[selectedNum][remain] = count;
        return count;
    }
    private int numOfSelected(boolean[] selected){
        int count = 0;
        for(boolean s: selected) count += (s?1:0);
        return count;
    }

}
```

### Final Solution - Math

First divide the problem into count for different length of digit. length can be between `[1, n]`.

Select digit one by one until length used up.

9 _ 9 _ 8 _ 7 _ 6 ...

First digit cannot be 0 except the number is right 0(this special case will be added in the end), so 9 possibilities. The second digit can be 0-9, but have to eliminate first digit that has been used, so it's 10-1=9 possibilities. All the following will get 1 substracted compared to previous digit.

For example,

length is 3, then 9*9*8 possibilities.

```
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        int ans = 0;
        for(int len=1; len<=n; len++){
            int count = 1;
            int times = 9; // 0-9 is 10 digit, subtract first one, then still 9 possibilities
            for(int j=len-1; j>0; j--){
                count *= times; // times is number of possible digits
                times--; // -1 since one digit was used
            }
            ans+=9*count; // 1-9 for first digit
        }
        return ans+1; // 0 is also valid, though 00,000,.. not valid
    }
}
```

## 361. Bomb Enemy

### Description

https://leetcode.com/problems/bomb-enemy/

### Final Solution - Presum DP

```
class Solution {
    public int maxKilledEnemies(char[][] grid) {
        int rowLen = grid.length;
        if(rowLen==0) return 0;
        int colLen = grid[0].length;
        int[][] topToBottom = new int[rowLen][colLen];
        int[][] bottomToTop = new int[rowLen][colLen];
        int[][] leftToRight = new int[rowLen][colLen];
        int[][] rightToLeft = new int[rowLen][colLen];
        initPresum(topToBottom, bottomToTop, leftToRight, rightToLeft, rowLen, colLen, grid);
        int max = 0;
        for(int i=0; i<rowLen; i++){
            for(int j=0; j<colLen; j++){
                if(grid[i][j]=='0') max = Math.max(max, topToBottom[i][j]+bottomToTop[i][j]+leftToRight[i][j]+rightToLeft[i][j]);
            }
        }
        return max;
    }
    private void initPresum(int[][] topToBottom, int[][] bottomToTop, int[][] leftToRight, int[][] rightToLeft, int rowLen, int colLen, char[][] grid){
        for(int j=0; j<colLen; j++){
            for(int i=0; i<rowLen; i++){
                if(grid[i][j]=='E') topToBottom[i][j] = (i-1>=0 ? topToBottom[i-1][j]+1 : 1);
                else if(grid[i][j]=='0') topToBottom[i][j] = (i-1>=0 ? topToBottom[i-1][j] : 0);
                else if(grid[i][j]=='W') topToBottom[i][j] = 0;
            }
            for(int i=rowLen-1; i>=0; i--){
                if(grid[i][j]=='E') bottomToTop[i][j] = (i+1<rowLen ? bottomToTop[i+1][j]+1 : 1);
                else if(grid[i][j]=='0') bottomToTop[i][j] = (i+1<rowLen ? bottomToTop[i+1][j] : 0);
                else if(grid[i][j]=='W') bottomToTop[i][j] = 0;
            }
        }
        for(int i=0; i<rowLen; i++){
            for(int j=0; j<colLen; j++){
                if(grid[i][j]=='E') leftToRight[i][j] = (j-1>=0 ? leftToRight[i][j-1]+1 : 1);
                else if(grid[i][j]=='0') leftToRight[i][j] = (j-1>=0 ? leftToRight[i][j-1] : 0);
                else if(grid[i][j]=='W') leftToRight[i][j] = 0;
            }
            for(int j=colLen-1; j>=0; j--){
                if(grid[i][j]=='E') rightToLeft[i][j] = (j+1<colLen ? rightToLeft[i][j+1]+1 : 1);
                else if(grid[i][j]=='0') rightToLeft[i][j] = (j+1<colLen ? rightToLeft[i][j+1] : 0);
                else if(grid[i][j]=='W') rightToLeft[i][j] = 0;
            }
        }
    }
}
```
