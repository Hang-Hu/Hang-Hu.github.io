## 279. Perfect Squares

### Description

```
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

### Best Solution - DP

OPT(i) = min k=1,2,3...&&k^2<=i {OPT(i-k^2)+OPT(k^2)}

Have to init opt[0] and opt[k^2].

```
class Solution {
    public int numSquares(int n) {
        int[] opt = new int[n+1];
        opt[0] = 0;
        // init opt when it comes to square numbers, the number used is just 1
        for(int k=1; k*k<=n; k++)    opt[k*k] = 1;
        for(int i=1; i<=n; i++){
            int min = Integer.MAX_VALUE;
            for(int k=1; k*k<=i; k++){
                int tmp = opt[i-k*k]+opt[k*k];
                if(tmp<min) min=tmp;
            }
            opt[i] = min;
        }
        return opt[n];
    }
}
```

## 72. Edit Distance

### Description

```
Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

### Solution

ignore x, y == delete x, y

delete x == insert y

replace x with y == replace y with x

So insert, delete and replace can be replace by ignoring x(-), ignoring y(|) and replacing(/).


`opt(i, j)` is the minimum cost spent when changing string x1...xi to y1...yj(0 is left for empty string)

if i=0, diff(empty, y1...yj): j
if j=0, diff(x1...xi, empty): i

```
opt(i, j) = min(
                opt(i-1, j-1)+0(xi==yj)/1(xi!=yj)
                opt(i-1, j)+1
                opt(i, j-1)+1
            )
```

```
class Solution {
    public int minDistance(String word1, String word2) {
        if(word1.length()==0) return word2.length();
        if(word2.length()==0) return word1.length();
        int[][] opt = new int[word1.length()+1][word2.length()+1];
        for(int i=0; i<opt.length; i++) opt[i][0] = i;
        for(int j=0; j<opt[0].length; j++) opt[0][j] = j;
        for(int i=1; i<opt.length; i++){
            for(int j=1; j<opt[0].length; j++){
                opt[i][j] = min(opt[i-1][j-1]+(word1.charAt(i-1)==word2.charAt(j-1)?0:1), opt[i-1][j]+1, opt[i][j-1]+1);
            }
        }
        return opt[opt.length-1][opt[0].length-1];
    }
    private int min(int a, int b, int c){
        return Math.min(a, Math.min(b, c));
    }
}
```

## 5. Longest Palindromic Substring

### Description

```
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
```

### Solution - DP

`opt(i, j)` is boolean, whether `s.substring(i, j+1)` is palindrome or not. Both i and j are inclusive

Length 1 word `(i, i)` and length 2 word `(i, i+1)` are set by for loop.

Then the length grows from `opt[i+1][i+x-1]` to `opt[i][i+x]`, which grows by 2. For example, from length 1 to 3, to 5, etc. And length 2 to 4, to 6, etc. Then I grow word's length from 1, 2 to 3,4,5,etc.

Finally just check the max of `j-i+1` where `opt(i, j)` is `true`.

Note that due to dependency of `opt[i+1][i+x-1]` to calculate `opt[i][i+x]`, I have to calculate crossly to final one slot.

Calculate in the following order.

1. (0, 2), (1, 3), (2, 4) // +2
2. (0, 3), (1, 4) // +3
3. (0, 4) //+4

```
| j\i | 0 | 1 | 2 | 3 | 4 |
|-----|---|---|---|---|---|
| 0   | T |   |   |   |   |
| 1   | F | T |   |   |   |
| 2   |   | F | T |   |   |
| 3   |   |   | F | T |   |
| 4   |   |   |   | F | T |
```

```
class Solution {
    public String longestPalindrome(String s) {
        int length = s.length();
        if(length==0) return "";
        boolean[][] opt = new boolean[length][length];
        for(int i=0; i<length; i++) opt[i][i] = true;
        for(int i=0; i+1<length; i++) opt[i][i+1] = (s.charAt(i)==s.charAt(i+1));
        for(int x=2; x<length; x++){
            for(int i=0; i+x<length; i++){
                opt[i][i+x] = (opt[i+1][i+x-1] && (s.charAt(i)==s.charAt(i+x)));
            }
        }
        int max = 0;
        int start = -1;
        int end = -1;
        for(int i=0; i<length; i++){
            for(int j=i; j<length; j++){
                if(opt[i][j] && j-i+1>max){
                    max = j-i+1;
                    start = i;
                    end = j;
                }
            }
        }
        return s.substring(start, end+1);
        
    }
}
```

Time: O(n^2). (n-2)^2/2 = O(n^2). Nearly half of the square.
Space: O(n^2).


### Final Solution - Recursion

Grow from one letter, grow if `s[i-1]==s[j+1]`, grow() return length, start and end index. Then grow from 2 letters if they are the same. This will cover 1,3,5 and 2,4,6 so covers every number. Finally compare the length and return the string of max length.

```
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()==0) return "";
        int max = 0;
        int start = -1;
        int end = -1;
        for(int i=0; i<s.length(); i++){
            Position res = grow(i, i, s);
            if(res.length>max){
                max = res.length;
                start = res.start;
                end = res.end;
            }
        }
        for(int i=0; i+1<s.length(); i++){
            if(s.charAt(i)!=s.charAt(i+1)) continue;
            Position res = grow(i, i+1, s);
            if(res.length>max){
                max = res.length;
                start = res.start;
                end = res.end;
            }
        }
        return s.substring(start, end+1);
    }
    // start, end are inclusive
    private Position grow(int start, int end, String s){
        if(start-1>=0&&end+1<s.length()&&s.charAt(start-1)==s.charAt(end+1)) return grow(start-1, end+1, s);
        return new Position(end-start+1, start, end);
    }
}
class Position{
    int length;
    int start;
    int end;
    public Position(int length, int start, int end){
        this.length = length;
        this.start = start;
        this.end = end;
    }
}
```

Time: O(n^2)
Space: O(1)

## 338. Counting Bits

### Description

```
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

Example 1:

Input: 2
Output: [0,1,1]
Example 2:

Input: 5
Output: [0,1,1,2,1,2]
Follow up:

It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
Space complexity should be O(n).
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
```


### Solution Naive

```
class Solution {
    public int[] countBits(int num) {
        int[] ans = new int[num+1];
        for(int i=0; i<=num; i++){
            ans[i] = numOfOnes(i);
        }
        return ans;
    }
    private int numOfOnes(int num){
        int count = 0;
        while(num>0){
            count+=(num&1);
            num = num>>>1;
        }
        return count;
    }
}
```

Time: O(n*logn). Since logn is the number of bits(size) for n.
Space: O(n)

### Final Solution - DP

opt(i) = last digit(1/0) + opt(i remove last digit). Since after removing last digit it's smaller than i, then that opt already exist, this saves time by reusing previous result.

```
class Solution {
    public int[] countBits(int num) {
        int[] opt = new int[num+1];
        for(int i=0; i<=num; i++) opt[i] = (i&1) + opt[i>>>1]; // have to use () for i&1 otherwise + will be executed first
        return opt;
    }
}
```

Time: O(n)
Space: O(n)

## 32. Longest Valid Parentheses

### Description

```
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

### Solution - Brute Force(TLE)

```
class Solution {
    public int longestValidParentheses(String s) {
        int max = 0;
        // i, j inclusive
        for(int i=0; i<s.length(); i++){
            for(int j=i+1; j<s.length(); j++){
                if(valid(s, i, j)) max = Math.max(max, j-i+1);
            }
        }
        return max;
    }
   // start, end inclusive
    private boolean valid(String s, int start, int end){
        int l = 0;
        int r = 0;
        for(int i=start; i<=end; i++){
            if(s.charAt(i)=='('){
                if(r>0) return false;
                else    l++;
            }else if(s.charAt(i)==')'){
                if(l>0) l--;
                else    return false;
            }
        }
        return l==0 && r==0;
    }
}
```

Time: O(n^3)

Space: O(1)

### Solution DP

If s[i-1]=='(':              opt[i] = 2+opt[i-2]; // may-be-valid()
If s[i-1-opt[i-1]]=='(':     opt[i] = 2+opt[i-1]+opt[i-1-opt[i-1]-1];// may-be-valid(valid-inside)

```
class Solution {
    public int longestValidParentheses(String s) {
        if(s.length()==0||s.length()==1) return 0;
        int[] opt = new int[s.length()];
        opt[0]=0;
        if(s.charAt(1)=='('){
            opt[1] = 0;
        }else{ // )
            if(s.charAt(0)=='(')    opt[1] = 2; //()
            else                    opt[1] = 0; //))
        }
        for(int i=2; i<s.length(); i++){
            if(s.charAt(i)=='('){
                opt[i] = 0;
            }else{ // )
                if(s.charAt(i-1)=='('){ // may-be-valid()
                    opt[i] = 2+opt[i-2];
                }else{ // ))
                    if(i-1-opt[i-1]>=0 && s.charAt(i-1-opt[i-1])=='('){ // may-be-valid(valid-inside)
                        if(i-1-opt[i-1]-1>=0)   opt[i] = 2+opt[i-1]+opt[i-1-opt[i-1]-1];
                        else                    opt[i] = 2+opt[i-1];
                    }else{ // )) or valid-inside))
                        opt[i] = 0;
                    }
                }
            }
        }
        int max = 0;
        for(int i=0; i<opt.length; i++){
            max = Math.max(max, opt[i]);
        }
        return max;
    }
}
```

Time: O(n)
Space: O(n)

### Final Solution - l==r

Walk throught string with one index. Only increment l and r, once invalid(r>l) reset l and r. Then walk through from length-1 to 0. l==r shows it's a valid substring, compare l+r with max.

```
class Solution {
    public int longestValidParentheses(String s) {
        int l = 0;
        int r = 0;
        int max = 0;
        for(int i=0; i<s.length(); i++){
            if(s.charAt(i)=='('){
                l++;
            }else{
                r++;
                if(r>l){
                    l = 0; r = 0;
                }
            }
            if(l==r) max = Math.max(max, l+r);
        }
        l = 0; r = 0;
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)=='('){
                l++;
                if(l>r){
                    l = 0; r = 0;
                }
            }else{
                r++;
            }
            if(l==r) max = Math.max(max, l+r);
        }
        return max;
    }
}
```


## 10. Regular Expression Matching

### Description

```
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
Example 4:

Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
Example 5:

Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
```

### Solution DP(Recursion+Memorization)

Be careful I have many choices for one case, for example, a* can match 0 which is "", or match "a" or match "aaa...". And the differnt matching of a* will influence next matching, for example, the matching of b* following it.

Why Backtracking? some path not call and try because not meet condition.

If i, j exceed limit: true(i, j finish successfully)
If j exceed i not: false(nothing to match anymore, but i not finish, so false)
If j not i finish: maybe it's multiple x* and can be treated as 0 match, so continue.
firstMatch: the same or j is .
If j+1 is *:
 1. match 0 time: i the same, j+2(skip char and *)
 2. match 1 or more time(only if firstMatch): i+1(next char), j the same
If j+1 isnot *:
 only if firstMatch, both go to next one(i+1, j+1) (if j+1 is * and firstMatch, for example a and a*, then I can use match 1 and match 0 to solve it, so I have to skip it here, otherwise will be duplicate computation, even it's dp and the earlier one have the true computation, I don't even want to call dup)

memo[i][j] uses `s.length()+1` since i may exceed, and since i+1 it will at most exceed one, uses `p.length()` since as long as j exceeds, it returns and not call memo using j.

Since i may exceed, but still valid when nextIsStar and match 0, so have to check i limitation before calling it with memo.

I used `int[][]` instead of `boolean[][]` because I need the default to know if it's has already been calculated or not.

The bottom up dp is very similiar, just calc memo[i][j] for each grid.

```
class Solution {
    int[][] memo; // 0 is default, 1 is true, -1 is false
    public boolean isMatch(String s, String p) {
        memo = new int[s.length()+1][p.length()];
        return isMatch(s, 0, p, 0);
    }
    private boolean isMatch(String s, int i, String p, int j){
        if(j>=p.length() && i>=s.length()) return true;
        if(j>=p.length() && i<s.length()) return false;
        if(memo[i][j]!=0) return memo[i][j]==1?true:false;
        boolean firstMatch = i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='.');
        boolean nextIsStar = j+1<p.length() && p.charAt(j+1)=='*';
        boolean ans = false;
        if(nextIsStar){ // x*, x can be . or any char
            ans = isMatch(s, i, p, j+2); // * match 0 of p[j]
            ans = ans || (firstMatch && isMatch(s, i+1, p, j)); // * match 1 or more of p[j]
        }else{ // point to same char or p[j] is ., then p[j] matches s[i]
            ans = firstMatch && isMatch(s, i+1, p, j+1);
        }
        memo[i][j] = ans==true?1:-1;
        return ans;
    }
}
```

m is s.length(), n is p.length().

Time: O(m*n), calculate each grid in memo[i][j] once, each takes O(1) time to calc.
Space: I(m*n)

## 44. Wildcard Matching

### Description

```
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "*"
Output: true
Explanation: '*' matches any sequence.
Example 3:

Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
Example 4:

Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
Example 5:

Input:
s = "acdcb"
p = "a*c?b"
Output: false
```

### Final Solution DP (Recursion+Memorization)

Similiar to 10.Regular Expression Matching.

If j is *, try match 0(j+1) and match 1 or more(i+1)
Otherwise check if first match, yes then try next pari(i+1, j+1)

Use int[][] memo to memory duplicate computation.

```
class Solution {
    private int[][] memo; // 0 is default, 1 is true, -1 is default
    public boolean isMatch(String s, String p) {
        // p exceed will return without calling memo, i exceed will call memo with i
        memo = new int[s.length()+1][p.length()];
        return isMatch(s, 0, p, 0);
    }
    private boolean isMatch(String s, int i, String p, int j){
        if(i>=s.length() && j>=p.length()) return true;
        if(i<s.length() && j>=p.length()) return false;
        if(memo[i][j]!=0) return memo[i][j]==1?true:false;
        boolean firstMatch = i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='?');
        boolean isStar = p.charAt(j)=='*';
        boolean ans = false;
        if(isStar){
            ans = isMatch(s, i, p, j+1); // match 0
            // match 1 or more, i have to be within limit so that can be matched by *
            ans = ans || (i<s.length() && isMatch(s, i+1, p, j));
        }else{
            ans = firstMatch && isMatch(s, i+1, p, j+1);
        }
        memo[i][j] = ans==true?1:-1;
        return ans;
    }
}
```

m is s.length(), n is p.length()

Time: O(m*n)
Space: I(m*n)

### Solution (KMP)

First time meet *, match 0 time. If encounter firstMatch is false, i and j go back to previous *, match time inc by 1. If all remaining j is *, then return true.

```
class Solution {
    public boolean isMatch(String s, String p) {
        int i=0, j=0, preStarIndexOfI=-1, preStarIndexOfJ=-1, matchNum=-1;
        while(i<s.length() && j<p.length()+1){ // j can exceed so that j can go back to use last * which is in len-1
            boolean firstMatch = j<p.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='?');
            boolean isStar = j<p.length() && (p.charAt(j)=='*');
            if(isStar){
                preStarIndexOfI = i;
                preStarIndexOfJ = j;
                matchNum = 0;
                j++; // match 0 time
            }else{
                if(firstMatch){
                    i++; j++;
                }else{
                    if(preStarIndexOfJ==-1) return false;
                    j = preStarIndexOfJ;
                    i = preStarIndexOfI;
                    matchNum++;
                    i += matchNum;
                    j++;
                }
            }
        }
        if(i>=s.length()){
            while(j<p.length()){
                if(p.charAt(j)!='*') return false;
                j++;
            }
            return true;
        }else{ // j>=p.length()+1
            return false;
        }
        
    }
}
```

## 62. Unique Paths

### Description

```
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
```

### Final Solution DP

opt(i, j) is the number of ways to reach bottom right corner from position (i, j).

```
(i, j)      (i+1, j)
(i, j+1)
```

```
opt(i, j) = opt(i+1, j)(if i+1 exist) + opt(i, j+1)(if j+1 exist)
```

Why use i+1 and j+1 exist condition?

The position of i+j may be in boundary, for example, i=m-1, j=1, then they only have bottom no right.

`opt[m-1][n-1]` is 1 because:

```

```

```
class Solution {
    public int uniquePaths(int m, int n) {
        if(m==0 || n==0) return 0;
        int[][] opt = new int[m][n];
        opt[m-1][n-1] = 1;
        for(int i=m-1; i>=0; i--){
            for(int j=n-1; j>=0; j--){
                if(i+1<m) opt[i][j] += opt[i+1][j];
                if(j+1<n) opt[i][j] += opt[i][j+1];
            }
        }
        return opt[0][0];
    }
}
```