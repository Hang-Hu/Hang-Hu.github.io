## class TreeNode

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
```


## 105. Construct Binary Tree from Preorder and Inorder Traversal

### Description

```
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
```

### First Version

```
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }
    // start is inclusive, end is exclusive
    private TreeNode build(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd){
        // end condition: no root
        if(pStart == pEnd){
            return null;
        }
        int rootVal = preorder[pStart];
        int rootIndex = findIndex(rootVal, inorder, iStart, iEnd);
        TreeNode rootNode = new TreeNode(rootVal);
        int lengthOfLeft = rootIndex - iStart;
        if(lengthOfLeft>0)  rootNode.left = build(preorder, pStart+1, pStart+1+lengthOfLeft, inorder, iStart, rootIndex);
        if(rootIndex+1 < iEnd) rootNode.right = build(preorder, pStart+1+lengthOfLeft, pEnd, inorder, rootIndex+1, iEnd);
        return rootNode;
    }
    private int findIndex(int val, int[] arr, int start, int end){
        for(int i=start; i<end; i++){
            if(arr[i] == val){
                return i;
            }
        }
        return -1;
    }

}
```

Time Complexity: findIndex is O(n), it will run findIndex height-1 times, so it's O(nlogn)
Space Complexity: O(n)

### Second Version (Best Solution)

I have to imporve the findIndex function to be O(1). Since duplicates do not exist in the tree, use map to find index.

```
class Solution {
    private Map<Integer, Integer> inorderMap; // (value, index)
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        inorderMap = new HashMap<>();
        for(int i=0; i<inorder.length; i++){
            inorderMap.put(inorder[i], i);
        }
        return build(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }
    // start is inclusive, end is exclusive
    private TreeNode build(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd){
        // end condition: no root
        if(pStart == pEnd){
            return null;
        }
        int rootVal = preorder[pStart];
        int rootIndex = inorderMap.get(rootVal);
        TreeNode rootNode = new TreeNode(rootVal);
        int lengthOfLeft = rootIndex - iStart;
        if(lengthOfLeft>0)  rootNode.left = build(preorder, pStart+1, pStart+1+lengthOfLeft, inorder, iStart, rootIndex);
        if(rootIndex+1 < iEnd) rootNode.right = build(preorder, pStart+1+lengthOfLeft, pEnd, inorder, rootIndex+1, iEnd);
        return rootNode;
    }
}
```

Time Complexity: traverse every node O(n), find index O(logn*1), use the bigger one, which is O(n)
Space Complexity: O(n)

## 144. Binary Tree Preorder Traversal

### Description

```
Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
```

### Code - recursion

```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        traverse(root, ans);
        return ans;
    }
    private void traverse(TreeNode root, List<Integer> ans){
        // end condition
        if(root == null)    return;
        
        ans.add(root.val);
        traverse(root.left, ans);
        traverse(root.right, ans);
    }
}
```

### Follow up - iteration

Recursive solution is trivial, could you do it iteratively?

Use stack to remember node which has to change itself to left child. When node is null, set it to TreeNode popped from stack, since left was used when pushed to stack, so node should go right. This time setting node to its right child, I don't have to remember it in stack, because its left and right children have been traversed, I don't need it anymore. If encounter null in right tree, just go back to any previous node whose right child not visited. 

Since it's preorder, I have to save the value of node to ans before going left.

```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while(node!=null || stack.empty()==false){
            if(node != null){// add to ans, push into stack, go left
                ans.add(node.val);
                stack.push(node);
                node = node.left;
            }else{// node is null: pop to node, and go right
                node = stack.pop().right;
            }
        }
        return ans;
    }
}
```

Time Complexity: O(n)
Space Complexity: O(n)

## 94. Binary Tree Inorder Traversal

### Description

```
Given a binary tree, return the inorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?
```

### Recursive

```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        traversal(root, res);
        return res;
    }
    private void traversal(TreeNode node, List<Integer> res){
        if(node == null)    return;
        traversal(node.left, res);
        res.add(node.val);
        traversal(node.right, res);
    }
}
```

### Iterative

```
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while(node != null || stack.empty() == false){
            if(node != null){
                stack.push(node);
                node = node.left;
            }else{
                node = stack.pop();
                ans.add(node.val);
                node = node.right;
            }
        }
        return ans;
    }
}
```

Time: O(n)
Space: ans contains every node, stack is logn, so O(n)

## 145. Binary Tree Postorder Traversal

### Description

```
Given a binary tree, return the postorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]
Follow up: Recursive solution is trivial, could you do it iteratively?

```

### Recursive

```
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        traversal(root, ans);
        return ans;
    }
    private void traversal(TreeNode node, List<Integer> ans){
        if(node == null)    return;
        traversal(node.left, ans);
        traversal(node.right, ans);
        ans.add(node.val);
    }
}
```

### Iterative

1. Node is `null` and left child: `peek()` and go right
2. Node is `null`/used and right child: `pop()` to `ansNodes`, `peek()` and go right
3. Otherwise `push()` and go left

Use `leftChild` to know if current `node` is its parents' left or right child.(`true`: left child, `false`: right child).

```
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<TreeNode> ansNodes = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        boolean leftChild = false;
        while(node!=null || !stack.empty()){
            if(node != null && (leftChild || !ansNodes.contains(node))){
                stack.push(node);
                node = node.left;
                leftChild = true;
            }else if(leftChild == true){// node is null and is left child
                node = stack.peek().right;
                leftChild = false;
            }else{//node is null or used and is right child
                ansNodes.add(stack.pop());
                if(stack.empty() == true)   break;
                node = stack.peek().right;
                leftChild = false;
            }
        }
        List<Integer> ans = new ArrayList<>();
        for(TreeNode n: ansNodes){
            ans.add(n.val);
        }
        return ans;
    }
}
```

Time: O(n)
Space: O(n)

## 102. Binary Tree Level Order Traversal

### Description

```
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

### Recursive

`ans.get(depth).add(node.val)`, so use node, depth, ans in parameter.

```
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        levelOrder(root, 0, ans);
        return ans;
    }
    private void levelOrder(TreeNode node, int depth, List<List<Integer>> ans){
        if(node == null)        return;
        // if ans.get(depth) not exist, new LinkedList
        if(depth+1>ans.size())  ans.add(new LinkedList<>());
        ans.get(depth).add(node.val);
        levelOrder(node.left, depth+1, ans);
        levelOrder(node.right, depth+1, ans);
    }
}
```


### Iterative

Like preorder iterative traversal, use stack to remember where is next node when it comes to null. Add val to ans the first time meeting node. Have variable depth and update it when going left or right.

```
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        int depth = 0;
        Stack<NodeDepth> stack = new Stack<>();
        TreeNode node = root;
        while(node != null || !stack.empty()){
            if(node == null){
                NodeDepth nodeDepth = stack.pop();
                node = nodeDepth.node.right;
                depth = nodeDepth.depth + 1;
            }else{
                stack.push(new NodeDepth(node, depth));
                if(depth+1>ans.size())  ans.add(new ArrayList<>());
                ans.get(depth).add(node.val);
                node = node.left;
                depth++;
            }
        }
        return ans;
    }
}
class NodeDepth{
    TreeNode node;
    int depth;
    NodeDepth(TreeNode node, int depth){
        this.node = node;
        this.depth = depth;
    }
}
```


## 107. Binary Tree Level Order Traversal II

### Description

```
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
```

### Recursive

The only difference between Binary Tree Level Order Traversal I, is that I reverse list before return.

```
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        levelOrder(root, 0, ans);
        Collections.reverse(ans);
        return ans;
    }
    private void levelOrder(TreeNode node, int depth, List<List<Integer>> ans){
        if(node == null)        return;
        if(depth+1>ans.size())  ans.add(new LinkedList<>());
        ans.get(depth).add(node.val);
        levelOrder(node.left, depth+1, ans);
        levelOrder(node.right, depth+1, ans);
    }
}
```

### Iterative

The same as recursive, the only difference: `Collections.reverse(ans)`.

```
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        int depth = 0;
        Stack<NodeDepth> stack = new Stack<>();
        TreeNode node = root;
        while(node != null || !stack.empty()){
            if(node == null){
                NodeDepth nodeDepth = stack.pop();
                node = nodeDepth.node.right;
                depth = nodeDepth.depth + 1;
            }else{
                stack.push(new NodeDepth(node, depth));
                if(depth+1>ans.size())  ans.add(new ArrayList<>());
                ans.get(depth).add(node.val);
                node = node.left;
                depth++;
            }
        }
        Collections.reverse(ans);
        return ans;
    }
}
class NodeDepth{
    TreeNode node;
    int depth;
    NodeDepth(TreeNode node, int depth){
        this.node = node;
        this.depth = depth;
    }
}
```

## 226. Invert Binary Tree


### Description

```
Invert a binary tree.

Example:

Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

### Analysis

First, 2 and 7 exchanged.

```
     4
   /   \
  7     2
 / \   / \
6   9 1   3
```

For 7, 6 and 9 changed.

For 2, 1 and 3 changed.

So that's left and right child changed.

### Recursive

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        traversal(root);
        return root;
    }
    private void traversal(TreeNode node){
        if(node == null)    return;
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;
        traversal(node.left);
        traversal(node.right);
    }
} 
```

### Iterative

Use preorder's stack, the first time meeting node, switch its left and right child.

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while(node!=null || !stack.empty()){
            if(node == null){
                node = stack.pop().right;
            }else{
                stack.push(node);
                TreeNode tmp = node.left;
                node.left = node.right;
                node.right = tmp;
                node = node.left;
            }
        }
        return root;
    }
}
```

## 230. Kth Smallest Element in a BST

### Description

```
Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note: 
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

Example 1:

Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1
Example 2:

Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
Follow up:
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?
```

### First Version

Add every value into list, and sort.

```
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> l = new ArrayList<>();
        traversal(root, l);
        Collections.sort(l);
        return l.get(k-1);
    }
    private void traversal(TreeNode root, List<Integer> l){
        if(root == null)    return;
        l.add(root.val);
        traversal(root.left, l);
        traversal(root.right, l);
    }
}
```

Time: each node is O(n), quick sort is O(nlogn), so O(nlogn)
Space: O(n)

### Second Version

Use inorder traversal, since it's BST, then the list I got is already sorted.

```
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> l = new ArrayList<>();
        traversal(root, l);
        return l.get(k-1);
    }
    private void traversal(TreeNode root, List<Integer> l){
        if(root == null)    return;
        traversal(root.left, l);
        l.add(root.val);
        traversal(root.right, l);
    }
}
```

Time: O(n)
Space: O(n)

### Recursive(Final)

Use instance variable `count` to remember this is the nth node inorder traversed. When `count` equals `k`, the remember the node.val in `ans`, which is the answer, and stop traversal.

```
class Solution {
    private int count;
    private int k;
    private int ans;
    public int kthSmallest(TreeNode root, int k) {
        this.count = 0;
        this.k = k;
        traversal(root);
        return ans;
    }
    private void traversal(TreeNode root){
        if(root == null)    return;
        traversal(root.left);
        this.count++;
        if(this.count == this.k){
            this.ans = root.val;
            return;
        }
        // l.add(root.val);
        traversal(root.right);
    }
}
```

### Iterative(Final)

Use inorder iterative traversal, add count and compare with k when second time meeting node.

```
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int count = 0;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while(node!=null || !stack.empty()){
            if(node == null){
                node = stack.pop();
                // second time meeting node
                count++;
                if(count == k)  return node.val;
                node = node.right;
            }else{
                stack.push(node);
                node = node.left;
            }
        }
        return -1;
    }
}
```


## 98. Validate Binary Search Tree

### Description

```
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:

Input:
    2
   / \
  1   3
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.
```

### Recursive

As it goes deeper, there are more and more limitations, but the newer limitations can overwrite the old ones. There are only two valid, lowerLimit and upperLimit. Going left, overwrite upperLimit. Going right, overwrite lowerLimit.

```
class Solution {
    public boolean isValidBST(TreeNode root) {
        return traverse(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    // lowerLimit < val < upperLimit must exist
    private boolean traverse(TreeNode node, long lowerLimit, long upperLimit){
        if(node == null)                                    return true;    
        if(node.val<=lowerLimit || node.val>=upperLimit)    return false;
        return traverse(node.left, lowerLimit, node.val) && traverse(node.right, node.val, upperLimit);
    }
}
```

### Iterative

Preorder iterative traversal, `WrappedNode` to save the context(`min`, `max`) of each node pushed into `stack`, so that when `pop()` I can restore the corresponding context(`min`, `max`).

```
class Solution {
    public boolean isValidBST(TreeNode root) {
        Stack<WrappedNode> stack = new Stack<>();
        TreeNode node = root;
        long min = Long.MIN_VALUE;
        long max = Long.MAX_VALUE;
        while(node!=null || !stack.empty()){
            if(node == null){
                WrappedNode wNode = stack.pop();
                max = wNode.max;
                node = wNode.node;
                min = node.val;
                node = node.right;
            }else{
                if(node.val<=min || node.val>=max)  return false;
                stack.push(new WrappedNode(node, min, max));
                max = node.val;
                node = node.left;
            }
        }
        return true;
    }
}
class WrappedNode{
    TreeNode node;
    long min;
    long max;
    public WrappedNode(TreeNode node, long min, long max){
        this.node = node;
        this.min = min;
        this.max = max;
    }
}
```

## 114. Flatten Binary Tree to Linked List

### Description

```
Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

### First Version

Do it in preorder.

If left child of current node exists: find left.right...right or left itself if left has no right child, the node found is named after x; move node.right to x.right; move node's left to node's right

node = node.right

until node == null

#### Recursive

```
class Solution {
    public void flatten(TreeNode root) {
        if(root==null)  return;
        if(root.left != null){
            TreeNode x = root.left;
            while(x.right!=null)    x = x.right;
            x.right = root.right;
            root.right = root.left;
            root.left = null;
        }
        flatten(root.right);
    }
}
```

#### Iterative

```
class Solution {
    public void flatten(TreeNode root) {
        TreeNode node = root;
        while(node!=null){
            if(node.left != null){
                TreeNode x = node.left;
                while(x.right!=null)    x = x.right;
                x.right = node.right;
                node.right = node.left;
                node.left = null;
            }
            node = node.right;
        }
    }
}
```

Time: O(nlogn)
Space: O(1)

### Second Version

Do it in post order.

For the preorder version, I have 2 while loops. For left's most left, I used while loop to get it, and the time complexity is O(logn) for that. To improve that, I used post order, got to leaf first, from bottom to up, adjust the structure and return the most right one so that I got x without many times going down to find most right.

If left exists, then adjust left to right:

1. move right to left's most right(l)'s right.
2. move left to right.

If no left or right, return node.
If no left, return right's most right(r).
If no right, return previous left's most right(l).
If left right both exist, return previous right's most right(r).

```
class Solution {
    public void flatten(TreeNode root) {
        postOrder(root);
    }
    private TreeNode postOrder(TreeNode node){
        if(node == null)    return null;
        TreeNode l = postOrder(node.left);
        TreeNode r = postOrder(node.right);
        if(node.left != null){
            l.right = node.right;
            node.right = node.left;
            node.left = null;    
        }
        if(r==null){
            if(l==null){
                return node;
            }else{
                return l;
            }
        }else{
            return r;
        }
    }
}
```

### Final Version Recursive

Preorder but O(n) time complexity and O(1) space.

Use instance variable `pre` to remember the previous node in preorder traversal, and change `pre`'s right to current node when visiting each node. Make sure to save `node.right` because after running `preorder(node.left)` node's right will be changed.

```
class Solution {
    private TreeNode pre;
    public void flatten(TreeNode root) {
        pre = null;
        preorder(root);
    }
    private void preorder(TreeNode node){
        if(node == null)    return;
        if(pre!=null){
            pre.right = node;
            pre.left = null;
        }
        pre = node;
        TreeNode right = node.right;
        preorder(node.left);// pre changed after running this line, node is its pre, so node's right also changed  after this line
        preorder(right);
    }
}
```

Time: O(n)
Space: O(1)

### Final Version Iterative

```
class Solution {
    public void flatten(TreeNode root) {
        TreeNode pre = new TreeNode(-1);
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while(node!=null || !stack.empty()){
            if(node==null){
                node = stack.pop();
            }else{
                pre.right = node;
                pre.left = null;
                pre = node;
                stack.push(node.right);//save node right child in stack because that's the only thing I want
                node = node.left;
            }
        }
    }
}
```

Time: O(n)
Space: O(n)

## 113. Path Sum II

### Description

```
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
```

### First Version

Go to bottom, and if sum can be extracted to 0, add to path, bottom up, returned list is index list in case many paths returned.

```
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<>();
        traversal(root, ans, sum);
        return ans;
    }
    //return list of index in ans, ans[index] is the path
    private List<Integer> traversal(TreeNode node, List<List<Integer>> ans, int sum){
        if(node == null)    return new ArrayList<>();
        if(node.val == sum && node.left == null && node.right == null){
            ans.add(new ArrayList<Integer>(){{add(node.val);}});
            return new ArrayList<Integer>(){{add(ans.size()-1);}};
        }
        List<Integer> is = traversal(node.left, ans, sum-node.val);
        List<Integer> js = traversal(node.right, ans, sum-node.val);
        for(int i: is)  ans.get(i).add(0, node.val);
        for(int j: js)  ans.get(j).add(0, node.val);
        is.addAll(js);
        return is;
    }
}
```

Time: O(n)
Space: O(n)

### Final Version(Recursive)

Use `path` to remember every node along the path, the third time accessing node, remove `node.val` from `path` so that `path` can be reused.

```
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<>();
        traversal(root, ans, new ArrayList<>(), sum);
        return ans;
    }
    private void traversal(TreeNode node, List<List<Integer>> ans, List<Integer> path, int sum){
        if(node == null)    return;
        path.add(node.val);
        if(sum == node.val && node.left == null && node.right == null){
            ans.add(new ArrayList<>(path));
        }
        traversal(node.left, ans, path, sum-node.val);
        traversal(node.right, ans, path, sum-node.val);
        path.remove(path.size()-1);
    }
}
```

Time: O(n)
Space: O(n)

## 437. Path Sum III

### Description

```
You are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```


### First Version

Use sumList to start from every node for path sum. When third time meeting the node, have to extract every sum and remove the one added by this node.

```
class Solution {
    private int ans;
    public int pathSum(TreeNode root, int sum) {
        this.ans = 0;
        List<Integer> sumList = new ArrayList<>();
        traversal(root, sum, sumList);
        return this.ans;
    }
    private void traversal(TreeNode node, int sum, List<Integer> sumList){
        if(node == null)    return;
        sumList.add(sum);
        for(int i=0; i<sumList.size(); i++){
            sumList.set(i, sumList.get(i)-node.val);
            if(sumList.get(i)==0)   this.ans++;
        }
        traversal(node.left, sum, sumList);
        traversal(node.right, sum, sumList);
        for(int i=0; i<sumList.size(); i++){
            sumList.set(i, sumList.get(i)+node.val);
        }
        sumList.remove(sumList.size()-1);
    }
}
```


### Final Version

Prefix sum.

sum(root, 3) - sum(root, 10) = sum(5, 3) == 8(which is the sum)

10,5,3 - 10 = 5,3

```
      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1
```


```
class Solution {
    public int pathSum(TreeNode root, int sum) {
        Map<Integer, Integer> map = new HashMap<>(); //(prefix sum, occurencies), use occurencies in case many in one path match
        map.put(0, 1);// in case leaf.val == sum
        return traversal(root, sum, map, 0);
    }
    private int traversal(TreeNode node, int sum, Map<Integer, Integer> map, int prefixSum){
        if(node==null)  return 0;
        prefixSum += node.val;
        int ans = 0;
        if(map.containsKey(prefixSum-sum))    ans+=map.get(prefixSum-sum);
        map.put(prefixSum, map.getOrDefault(prefixSum, 0)+1);
        ans += traversal(node.left, sum, map, prefixSum);
        ans += traversal(node.right, sum, map, prefixSum);
        map.put(prefixSum, map.get(prefixSum)-1);
        return ans;
    }
}
```

## 106. Construct Binary Tree from Inorder and Postorder Traversal

### Description

```
Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
```

### First&Final Version

Used inStart, inEnd, postStart, postEnd to get subtree, and divide array into smaller part to deal with.

Do it recursively, construct node and return.

```
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return recur(inorder, postorder, 0, inorder.length, 0, postorder.length);
    }
    //start inclusive, end exclusive
    private TreeNode recur(int[] inorder, int[] postorder, int inStart, int inEnd, int postStart, int postEnd){
        if(inStart>=inEnd) return null;
        int root = postorder[postEnd-1];
        int inRootIndex = findIndex(inorder, root);
        int sizeOfLeft = inRootIndex-inStart;
        TreeNode left = recur(inorder, postorder, inStart, inRootIndex, postStart, postStart+sizeOfLeft);
        TreeNode right = recur(inorder, postorder, inRootIndex+1, inEnd, postStart+sizeOfLeft, postEnd-1);
        TreeNode node = new TreeNode(inorder[inRootIndex]);
        node.left = left;
        node.right = right;
        return node;
    }
    private int findIndex(int[] arr, int x){
        for(int i=0; i<arr.length; i++){
            if(arr[i]==x)   return i;
        }
        return -1;
    }
}
```

## 889. Construct Binary Tree from Preorder and Postorder Traversal

### Description

```
Return any binary tree that matches the given preorder and postorder traversals.

Values in the traversals pre and post are distinct positive integers.

 

Example 1:

Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
Output: [1,2,3,4,5,6,7]
 

Note:

1 <= pre.length == post.length <= 30
pre[] and post[] are both permutations of 1, 2, ..., pre.length.
It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.
```

### First & Final Version

inStart, inEnd, postStart, postEnd, recursive, construct node and return

Be careful about null end condition, and cases when there is one node left(preStart+1 == preEnd).

```
class Solution {
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        return recur(pre, post, 0, pre.length, 0, post.length);
    }
    //start inclusive, end exclusive
    private TreeNode recur(int[] pre, int[] post, int preStart, int preEnd, int postStart, int postEnd){
        if(preStart>=preEnd || preStart<0 || preEnd>pre.length || postStart<0 || postEnd>post.length)    return null;
        if(preStart+1 == preEnd){
            return new TreeNode(pre[preStart]);
        }
        int root = pre[preStart];
        int rRoot = post[postEnd-2];
        int preRightStartIndex = findIndex(pre, rRoot);
        int leftSize = preRightStartIndex-(preStart+1);
        TreeNode l = recur(pre, post, preStart+1, preRightStartIndex, postStart, postStart+leftSize);
        TreeNode r = recur(pre, post, preRightStartIndex, preEnd, postStart+leftSize, postEnd-1);
        TreeNode node = new TreeNode(root);
        node.left = l;
        node.right = r;
        return node;
    }
    private int findIndex(int[] arr, int x){
        for(int i=0; i<arr.length; i++){
            if(arr[i]==x)   return i;
        }
        return -1;
    }
}
```

## 124. Binary Tree Maximum Path Sum

### Description

```
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

### First Version

The same logic as Path Sum III brute force recursion version.

For each node, assume it to be the parent node, get the node.val+maxSum of left+maxSum of right. Do it for all nodes to get max.

```
class Solution {
    public int maxPathSum(TreeNode root) {
        if(root==null)  return Integer.MIN_VALUE;
        return max(root.val+helper(root.left, 0, 0)+helper(root.right, 0, 0), maxPathSum(root.left), maxPathSum(root.right));
    }
    private int helper(TreeNode node, int max, int sum){
        if(node==null)  return max;
        sum += node.val;
        if(sum > max)   max = sum;
        max = helper(node.left, max, sum);
        return helper(node.right, max, sum);
    }
    private int max(int a, int b, int c){
        if(a>b){
            if(a>c) return a;
            else    return c;
        }else{
            if(b>c) return b;
            else    return c;
        }
    }
}
```


### Use array to remember max

```
class Solution {
    public int maxPathSum(TreeNode root) {
        if(root==null)  return Integer.MIN_VALUE;
        int[] l = new int[1];
        int[] r = new int[1];
        helper(root.left, l, 0);
        helper(root.right, r, 0);
        int itself = root.val + l[0] + r[0];
        return max(itself, maxPathSum(root.left), maxPathSum(root.right));
    }
    private void helper(TreeNode node, int[] max, int sum){
        if(node==null)  return;
        sum += node.val;
        if(sum > max[0])   max[0] = sum;
        helper(node.left, max, sum);
        helper(node.right, max, sum);
    }
    private int max(int a, int b, int c){
        if(a>b){
            if(a>c) return a;
            else    return c;
        }else{
            if(b>c) return b;
            else    return c;
        }
    }
}
```

Time: O(n^2)
Space: O(1)

### Final Version

Do two things in one method, 

answer, which is maximum path from node to left and right: `l+r+node.val`, use ans array to remember.

What helper did in previous version, which is max sum from node to its decendent node: `node.val+Math.max(l, r)`, use return to remember.


```
class Solution {
    public int maxPathSum(TreeNode root) {
        int[] ans = new int[1];
        ans[0] = Integer.MIN_VALUE;
        maxPathSum(root, ans);
        return ans[0];
    }
    // return max path sum from this node(inclusive) to its decendent node
    private int maxPathSum(TreeNode node, int[] ans){
        if(node == null)    return 0;
        int l = Math.max(0, maxPathSum(node.left, ans));
        int r = Math.max(0, maxPathSum(node.right, ans));
        ans[0] = Math.max(ans[0], l+r+node.val);
        return node.val+Math.max(l, r);
    }
}
```

Time: O(n)
Space: O(1)

## 173. Binary Search Tree Iterator

### Description

```
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
```

### Stack Version

```
public class BSTIterator {
    private Stack<TreeNode> stack;
    private TreeNode node;
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();
        node = root;
    }
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        if(node==null && stack.empty()){
            return false;
        }else{
            return true;
        }
    }
    /** @return the next smallest number */
    public int next() {
        while(true){
            if(node==null){
                node = stack.pop();
                int ans = node.val;
                node = node.right;
                return ans;
            }else{
                stack.push(node);
                node = node.left;                
            }    
        }
    }
}
/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
```

Time: O(n)
Space: O(logn)

***Stack for binary tree preorder/inorder traversal takes O(logn) space.***

### Version without Stack: Morris Traversal

## 199. Binary Tree Right Side View

### Description

```
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

Example:

Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

### Final Recursive Version

List<Integer> ans, overwrite ans[depth] so that the final one left will be the right one. Preorder.

```
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        traversal(root, ans, 0);
        return ans;
    }
    private void traversal(TreeNode node, List<Integer> ans, int depth){
        if(node == null)        return;
        if(depth+1>ans.size())  ans.add(node.val);
        else                    ans.set(depth, node.val);
        traversal(node.left, ans, depth+1);
        traversal(node.right, ans, depth+1);
    }
}
```

### Final Iterative Version

```
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Stack<NodeDepth> stack = new Stack<>();
        TreeNode node = root;
        int depth = 0;
        while(node!=null || !stack.empty()){
            if(node == null){
                NodeDepth nodeD = stack.pop();
                node = nodeD.node.right;
                depth = nodeD.depth+1;
            }else{
                if(depth+1>ans.size())  ans.add(node.val);
                else                    ans.set(depth, node.val);
                stack.push(new NodeDepth(node, depth));
                node = node.left;
                depth++;
            }
        }
        return ans;
    }
}
class NodeDepth{
    TreeNode node;
    int depth;
    public NodeDepth(TreeNode node, int depth){
        this.node = node;
        this.depth = depth;
    }
}
```

## 236. Lowest Common Ancestor of a Binary Tree

### Description

```
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]


 

Example 1:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
Example 2:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
 

Note:

All of the nodes' values will be unique.
p and q are different and both values will exist in the binary tree.
```

### First Version

When node is p or q, return count 1, add count+l+r. When 3rd time meeting the node(returning back), if count is 2 and ans[0] not set then this is the lowest parent node.

```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode[] ans = new TreeNode[1];
        traversal(root, p, q, ans);
            return ans[0];
    }
    private int traversal(TreeNode node, TreeNode p, TreeNode q, TreeNode[] ans){
        if(node == null)            return 0;
        int count = 0;
        if(node == p || node == q)  count = 1;
        count += traversal(node.left, p, q, ans);
        count += traversal(node.right, p, q, ans);
        if(count == 2 && ans[0] == null)  ans[0] = node;
        return count;
    }
}
```

### Final Version

Recursive. Directly return TreeNode. If l or r one not null, return that node, if both not null, then this is the lowest parent, return node.

```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return traversal(root, p, q);
    }
    private TreeNode traversal(TreeNode node, TreeNode p, TreeNode q){
        if(node == null)            return null;
        if(node == p || node == q)  return node;
        TreeNode l = traversal(node.left, p, q);
        TreeNode r = traversal(node.right, p, q);
        if(l==null){
            return r;
        }else{
            if(r==null){
                return l;
            }else{
                return node;
            }
        }
    }
}
```

## 116. Populating Next Right Pointers in Each Node

### Description

```
Given a binary tree

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
Recursive approach is fine, implicit stack space does not count as extra space for this problem.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
Example:

Given the following perfect binary tree,

     1
   /  \
  2    3
 / \  / \
4  5  6  7
After calling your function, the tree should look like:

     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL
```

### Final Version

Recursive because implicit stack not count as extra space. 

1. root points to null
2. left points to right
3. right points to next's left(if next == null, then right points to null)

```
public class Solution {
    public void connect(TreeLinkNode root) {
        if(root == null)    return;
        traversal(root);
    }
    private void traversal(TreeLinkNode node){
        if(node.left == null)   return;
        node.left.next = node.right;
        node.right.next = node.next != null ? node.next.left : null;
        traversal(node.left);
        traversal(node.right);
    }
}
```

## 117. Populating Next Right Pointers in Each Node II

### Description

```
Given a binary tree

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
Recursive approach is fine, implicit stack space does not count as extra space for this problem.
Example:

Given the following binary tree,

     1
   /  \
  2    3
 / \    \
4   5    7
After calling your function, the tree should look like:

     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \    \
4-> 5 -> 7 -> NULL
```

### Final Version

Level order.

node from start to the end of level l, parent from start to the end of level l-1. Contruct all the next of current level l, then move parent to sentinel.next, which is the first node in level l.

```
public class Solution {
    public void connect(TreeLinkNode root) {
        TreeLinkNode parent = root;
        while(parent!=null){
            TreeLinkNode node = new TreeLinkNode(-1);
            TreeLinkNode sentinel = node;
            while(parent!=null){
                if(parent.left!=null){
                    node.next = parent.left;
                    node = node.next;
                }
                if(parent.right!=null){
                    node.next = parent.right;
                    node = node.next;
                }
                parent = parent.next;
            }
            parent = sentinel.next;
        }
    }
}
```

## 96. Unique Binary Search Trees

### Description

```
Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?

Example:

Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```


### recursion+memory Version

DP is iteration of recursion+memory.

Assume i as root to divide problem, numTrees(n) = sum i=1-n numTrees(i-1)*numTrees(n-i)

```
class Solution {
    Map<Integer, Integer> map = new HashMap<>(); //(n, num of unique trees)
    public int numTrees(int n) {
        if(n==0)    return 1;
        if(n==1)    return 1;
        if(map.containsKey(n))  return map.get(n);
        int ans = 0;
        for(int i=1; i<=n; i++){
            ans += numTrees(i-1)*numTrees(n-i);
        }
        map.put(n, ans);
        return ans;
    }
}
```

### DP Final Version

Use array to replace method numTrees.

```
class Solution {
    public int numTrees(int n) {
        int[] arr = new int[n+1]; //arr[0] won't be used
        arr[0]=1;
        arr[1]=1;
        for(int i=2; i<=n; i++){ // i is n, start from n==2 because 0 and 1 already specified
            for(int j=1; j<=i; j++){ // j is i
                arr[i] += arr[j-1]*arr[i-j];
            }
        }
        return arr[n]; // the same as numTrees(n)
    }
}
```

## 95. Unique Binary Search Trees II

### Description

```
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.

Example:

Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

### First Version Recursive

Recursive construct subtree, root with leftList and rightList, since it's product so use two for loops. Because they it's going down more trees generate, when returning back(post order) then construct many root and set left as well as right.

```
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if(n==0)    return new ArrayList<TreeNode>();
        else        return traversal(1, n);
    }
    // start and end are inclusive
    private List<TreeNode> traversal(int start, int end){
        if(start>end)   return new ArrayList<TreeNode>(){{add(null);}};
        List<TreeNode> roots = new ArrayList<>();
        for(int i=start; i<=end; i++){
            List<TreeNode> leftList = traversal(start, i-1);
            List<TreeNode> rightList = traversal(i+1, end);
            for(TreeNode left: leftList){
                for(TreeNode right: rightList){
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    roots.add(root);
                }
            }
        }
        return roots;
    }
}
```

### Recursive + Mem Version -> traversal(start, end)

```
class Solution {
    Map<Integer, List<TreeNode>> map = new HashMap<>(); // (n, rootList)
    public Solution(){
        map.put(0, new ArrayList<TreeNode>(){{add(null);}});
        map.put(1, new ArrayList<TreeNode>(){{add(new TreeNode(1));}});
    }
    public List<TreeNode> generateTrees(int n) {
        if(n==0)    return new ArrayList<TreeNode>();
        else        return traversal(1, n);
    }
    // start and end are inclusive
    private List<TreeNode> traversal(int start, int end){
        int n = end+1-start;
        if(map.containsKey(n)){
            List<TreeNode> roots = map.get(n);
            return adjust(roots, start);
        }
        List<TreeNode> roots = new ArrayList<>();
        for(int i=start; i<=end; i++){
            List<TreeNode> leftList = traversal(start, i-1);
            List<TreeNode> rightList = traversal(i+1, end);
            for(TreeNode left: leftList){
                for(TreeNode right: rightList){
                    TreeNode root = new TreeNode(i);//Don't adjust here otherwise in traversal there are different start, and hence the adjustment value is different, makng the result wield
                    root.left = left;
                    root.right = right;
                    roots.add(root);
                }
            }
        }
        map.put(n, adjust(roots, -start+2));
        return roots;
    }
    private List<TreeNode> adjust(List<TreeNode> roots, int offset){
        List<TreeNode> adjustedRoots = new ArrayList<>();
        for(TreeNode root: roots)   adjustedRoots.add(update(root, offset));
        return adjustedRoots;
    }
    private TreeNode update(TreeNode root, int offset){
        if(root == null)    return null;
        TreeNode newRoot = new TreeNode(root.val+offset-1);
        newRoot.left = update(root.left, offset);
        newRoot.right = update(root.right, offset);
        return newRoot;
    }
}
```

### Recursive+Mem updated version -> use traversal(n)

```
class Solution {
    Map<Integer, List<TreeNode>> map = new HashMap<>(); // (n, rootList)
    public Solution(){
        map.put(0, new ArrayList<TreeNode>(){{add(null);}});
        map.put(1, new ArrayList<TreeNode>(){{add(new TreeNode(1));}});
    }
    public List<TreeNode> generateTrees(int n) {
        if(n==0)    return new ArrayList<TreeNode>();
        else        return traversal(n);
    }
    // start and end are inclusive
    private List<TreeNode> traversal(int n){
        if(map.containsKey(n))   return map.get(n);
        map.put(n, new ArrayList<TreeNode>());
        for(int i=1; i<=n; i++){
            for(TreeNode left: traversal(i-1)){// left is from 1 to i-1, no adjust required
                for(TreeNode right: adjust(traversal(n-i), i)){
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    map.get(n).add(root);
                }
            }
        }
        return map.get(n);
    }
    private List<TreeNode> adjust(List<TreeNode> roots, int offset){
        List<TreeNode> adjustedRoots = new ArrayList<>();
        for(TreeNode root: roots)   adjustedRoots.add(update(root, offset));
        return adjustedRoots;
    }
    private TreeNode update(TreeNode root, int offset){
        if(root == null)    return null;
        TreeNode newRoot = new TreeNode(root.val+offset);
        newRoot.left = update(root.left, offset);
        newRoot.right = update(root.right, offset);
        return newRoot;
    }
}
```


### Final Version DP

```
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if(n==0)    return new ArrayList<TreeNode>();
        List<TreeNode>[] arr = new ArrayList[n+1];// from 1 to n
        arr[0] = new ArrayList<TreeNode>(){{add(null);}};
        arr[1] = new ArrayList<TreeNode>(){{add(new TreeNode(1));}};
        for(int i=2; i<=n; i++){
            arr[i] = new ArrayList<TreeNode>();
            for(int j=1; j<=i; j++){// i is n, j is i(j is root)
                List<TreeNode> leftList = arr[j-1]; // adjust(arr[j-1], 0) makes no changes
                List<TreeNode> rightList = adjust(arr[i-j], j);
                for(TreeNode left: leftList){
                    for(TreeNode right: rightList){
                        TreeNode root = new TreeNode(j);
                        root.left = left;
                        root.right = right;
                        arr[i].add(root);
                    }
                }
            }
        }
        return arr[n];
    }
    
    private List<TreeNode> adjust(List<TreeNode> roots, int offset){
        List<TreeNode> adjustedRoots = new ArrayList<>();
        for(TreeNode root: roots)   adjustedRoots.add(update(root, offset));
        return adjustedRoots;
    }
    // + offset for each node
    private TreeNode update(TreeNode root, int offset){
        if(root == null)    return null;
        TreeNode newRoot = new TreeNode(root.val+offset);
        newRoot.left = update(root.left, offset);
        newRoot.right = update(root.right, offset);
        return newRoot;
    }
}
```

## 129. Sum Root to Leaf Numbers

### Description

```
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

### Iterative

```
class Solution {
    public int sumNumbers(TreeNode root) {
        if(root == null)    return 0;
        int ans = 0;
        TreeNode node = root;
        Stack<NodeNum> stack = new Stack<>();
        int num = 0;
        while(node!=null || !stack.empty()){
            if(node==null){
                NodeNum nodeN = stack.pop();
                num = nodeN.num;
                node = nodeN.node.right;
            }else{
                num = 10*num + node.val;
                if(node.left==null && node.right == null){
                    ans+=num;
                    node = null;
                    continue;
                }
                stack.push(new NodeNum(node, num));
                node = node.left;
            }
        }
        return ans;
    }
    
}
class NodeNum{
    TreeNode node;
    int num;
    public NodeNum(TreeNode node, int num){
        this.node = node;
        this.num = num;
    }
}
```

### Final Version Recursive

```
class Solution {
    public int sumNumbers(TreeNode root) {
        if(root == null)    return 0;
        int[] ans = new int[1];
        traversal(root, ans, 0);
        return ans[0];
    }
    private void traversal(TreeNode node, int[] ans, int num){
        num = 10*num + node.val;
        if(node.left == null && node.right ==null){ // node is leaf
            ans[0] += num;
            return;
        }
        if(node.left!=null)     traversal(node.left, ans, num);
        if(node.right!=null)    traversal(node.right, ans, num);
    }
}
```


## 222. Count Complete Tree Nodes

### Description

```
Given a complete binary tree, count the number of nodes.

Note:

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Example:

Input: 
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
```

### Final Version

My previous idea is to from right to left, and find the first node with depth == tree's depth, count the number of null nodes in its right side. However, the worst case for this method is that there is only one node in last level, then I have to traversal every node, the time complexity is O(n), so abandon this idea.

if height(root.right) == h-1, then last leaf is in right subtree, left subtree is complete and full binary tree with height h-1. if height(root.right) == h-2, then last leaf is in left subtree, right subtree is full tree with height h-2.

Number of nodes for full binary with height h is `2^(h+1)-1`, which equals `(1<<h+1)-1`

```
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null)    return 0;
        int h = height(root);
        if(height(root.right) == h-1){//last leaf is in right subtree
            return (1<<h) - 1 + countNodes(root.right) + 1;
        }else{//last leaf is in left subtree
            return countNodes(root.left) + ((1<<h-1) - 1) + 1;
        }
    }
    private int height(TreeNode node){// null is -1, leaf is 0
        return node == null ? -1 : 1+height(node.left);
    }    
}
```

Time: O(lgn*lgn). Because height() is logn, the recursion going down from root to leaf and it's logn, so logn*logn.
Space: O(1)

## 99. Recover Binary Search Tree

### Description

```
Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.

Example 1:

Input: [1,3,null,null,2]

   1
  /
 3
  \
   2

Output: [3,1,null,null,2]

   3
  /
 1
  \
   2
Example 2:

Input: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

Output: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
Follow up:

A solution using O(n) space is pretty straight forward.
Could you devise a constant space solution?
```

### Final Version

Swap `first` and `second`.

if `node.val<pre.val`, for `first` choose bigger one(pre), for `second` choose smaller one(node).

Set `second` together with `first` in case there is one confict, then I have to swap the two nodes in that one confict. Be careful `pre` is not parent, use `pre[0]` or instance variable.

```
class Solution {
    public void recoverTree(TreeNode root) {
        TreeNode[] pre = new TreeNode[1];
        pre[0] = new TreeNode(Integer.MIN_VALUE);
        TreeNode[] nodes = new TreeNode[2];
        inorder(root, pre, nodes);
        swap(nodes[0], nodes[1]);
    }
    // inorder is ascending, node.val must > pre.val
    private void inorder(TreeNode node, TreeNode[] pre, TreeNode[] nodes){
        if(node == null)    return;
        inorder(node.left, pre, nodes);
        if(node.val<pre[0].val){
            if(nodes[0]==null){//first
                nodes[0] = pre[0];
                nodes[1] = node;//set node in case there is no second wrong comparison
            }else{//second
                nodes[1] = node;
            }
        }
        pre[0] = node;
        inorder(node.right, pre, nodes);
    }
    private void swap(TreeNode p, TreeNode q){
        int tmp = p.val;
        p.val = q.val;
        q.val = tmp;
    }
}
```


## 297. Serialize and Deserialize Binary Tree


### Description

```
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Example: 

You may serialize the following tree:

    1
   / \
  2   3
     / \
    4   5

as "[1,2,3,null,null,4,5]"
Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
```

### First Version -- Leetcode serializer/deserializer

Encode: List<List<Integer>> and preorder, then flatten list deleting last List which is null level.

Decode: String Queue and Node Queue, `poll` value from `strQ` and construct node, `add` to `nodeQ`. For every next `node`, poll from `nodeQ`.

```
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null)    return "[]";
        List<List<Integer>> l = new ArrayList<>();
        encode(root, l, 0);
        List<Integer> flatList = new ArrayList<>();
        // last level is null level, don't need it
        for(int i=0; i<l.size()-1; i++) flatList.addAll(l.get(i));
        return flatList.toString();
    }
    private void encode(TreeNode node, List<List<Integer>> l, int depth){
        if(depth+1>l.size())  l.add(new ArrayList<Integer>());
        if(node == null){
            l.get(depth).add(null);
            return;
        }
        l.get(depth).add(node.val);
        encode(node.left, l, depth+1);
        encode(node.right, l, depth+1);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.equals("[]"))   return null;
        data = data.replace("[", "").replace("]", "");
        Queue<String> strQ = new LinkedList<String>(Arrays.asList(data.split(", ")));
        Queue<TreeNode> nodeQ = new LinkedList<>();
        TreeNode root = new TreeNode(Integer.parseInt(strQ.poll()));
        decode(strQ, nodeQ, root);
        return root;
    }
    private void decode(Queue<String> strQ, Queue<TreeNode> nodeQ, TreeNode node){
        if(strQ.size() == 0)    return;
        String l = strQ.poll();
        if(!l.equals("null")){
            node.left = new TreeNode(Integer.parseInt(l));
            nodeQ.add(node.left);    
        }
        String r = strQ.poll();
        if(!r.equals("null")){
            node.right = new TreeNode(Integer.parseInt(r));
            nodeQ.add(node.right);
        }
        decode(strQ, nodeQ, nodeQ.poll());
    }
}
```

### Second Version

Encode preorder, so decode also preorder. "N" is null, encoded into comma-seperated String.

```
public class Codec {
    public String serialize(TreeNode root) {
        if(root==null)  return "N";
        return root.val + "," + serialize(root.left) + "," + serialize(root.right);
    }
    public TreeNode deserialize(String data) {
        String[] strArr = data.split(",");
        int[] strIndex = new int[1];
        return decode(strArr, strIndex);
    }
    private TreeNode decode(String[] strArr, int[] strIndex){
        String s = strArr[strIndex[0]++];
        if(!s.equals("N")){
            TreeNode node = new TreeNode(Integer.parseInt(s));
            node.left = decode(strArr, strIndex);
            node.right = decode(strArr, strIndex);
            return node;
        }else{
            return null;
        }
    }
}
```

