## 957. Prison Cells After N Days


### Description

```
There are 8 prison cells in a row, and each cell is either occupied or vacant.

Each day, whether the cell is occupied or vacant changes according to the following rules:

If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.
Otherwise, it becomes vacant.
(Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.)

We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.

Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)

 

Example 1:

Input: cells = [0,1,0,1,1,0,0,1], N = 7
Output: [0,0,1,1,0,0,0,0]
Explanation: 
The following table summarizes the state of the prison on each day:
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]

Example 2:

Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000
Output: [0,0,1,1,1,1,1,0]
 

Note:

cells.length == 8
cells[i] is in {0, 1}
1 <= N <= 10^9
```

### Final Solution - Repetition + Map

1. simulate the update day by day
2. Use cells and cells2 to in turn update status
2. That will exceed the time limit. As there are 2^8=256 possibilities. There will definitely be repetition of status. Store each day's value and i for ith day to Map, when it comes to the same value, use % to cut the repeated status.


```
class Solution {
    public int[] prisonAfterNDays(int[] cells, int N) {
        int[] cells2 = new int[cells.length];
        Map<Integer, Integer> map = new HashMap<>(); // (cell integer, i)
        boolean found = false;
        int[] cellsUsed = cells;
        int[] cellsToUse = cells2;
        for(int i=0; i<N; i++){
            int value = toValue(cellsUsed);
            if(found==false && map.containsKey(value)){
                found = true;
                i = N-(N-i)%(i-map.get(value))-1;
                continue;
            }
            map.put(value, i);
            for(int j=0; j<cellsToUse.length; j++){
                if(j==0 || j==cells.length-1) cellsToUse[j] = 0;
                else cellsToUse[j] = updateState(cellsUsed[j-1], cellsUsed[j+1]);                    
            }
            // switch
            if(cellsUsed==cells){
                cellsUsed = cells2;
                cellsToUse = cells;
            }else{
                cellsUsed = cells;
                cellsToUse = cells2;
            }
        }
        return cellsUsed==cells ? cells : cells2;
    }
    private int toValue(int[] arr){
        int ans = 0;
        for(int i=0; i<arr.length; i++){
            ans = ans*10;
            ans += arr[i];
        }
        return ans;
    }
    private int updateState(int n1, int n2){
        if(n1==n2) return 1;
        else return 0;
    }
}
```

## 1000. Minimum Cost to Merge Stones

### 

### Solution

```
class Solution {
    public int mergeStones(int[] stones, int K) {
        // move window to find one with min sum, add them up, replace that with the added number, continue until 1 element or 1<number<K (return -1)
        int index = -1;
        int min = Integer.MAX_VALUE;
        for(int i=0; i+K-1<stones.length; i++){
            int sumNum = sum(i, i+K, stones);
            if(sumNum<min){
                min = sumNum;
                index = i;
            }
        }
        
    }
    // start is inclusive, end is exclusive
    private int sum(int start, int end, int[] stones){
        int ans = 0;
        for(int i=start; i<end; i++) ans += stones[i];
        return ans;
    }
}
```