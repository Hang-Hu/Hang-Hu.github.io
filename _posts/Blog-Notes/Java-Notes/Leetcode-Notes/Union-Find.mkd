## 261. Graph Valid Tree

### Solution DFS+Visited+Parent+ HashMap as graph


idea: dfs + parent + visited set since no edges like below.

```
1 - 2 - 3
 \-/
```

```
class Solution {
    public boolean validTree(int n, int[][] edges) {
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        initGraph(graph, edges);
        Set<Integer> visited = new HashSet<>();
        if(dfs(graph, 0, null, visited)==false) return false;
        return visitAll(n, visited);
    }
    private boolean visitAll(int n, Set<Integer> visited){
        for(int i=0; i<n; i++){
            if(visited.contains(i)==false)  return false;
        }
        return true;
    }
    private boolean dfs(Map<Integer, Set<Integer>> graph, Integer node, Integer parent, Set<Integer> visited){
        visited.add(node);
        Set<Integer> nextNodes = graph.get(node);
        if(nextNodes!=null){
            for(Integer next: nextNodes){
                if(visited.contains(next)){
                    if(next.equals(parent)) continue;
                    else                    return false;
                }
                if(dfs(graph, next, node, visited)==false)  return false;
            }
        }
        return true;
    }
    private void initGraph(Map<Integer, Set<Integer>> graph, int[][] edges){
        for(int i=0; i<edges.length; i++){
            int first = edges[i][0];
            int second = edges[i][1];
            // add first->second and second->first since it's undirected graph
            // and data structure is map
            if(graph.containsKey(first)==false) graph.put(first, new HashSet<Integer>());
            graph.get(first).add(second);
            if(graph.containsKey(second)==false) graph.put(second, new HashSet<Integer>());
            graph.get(second).add(first);
        }
    }
}
```

Time: O(m) and m is `edges.length`, which at most can be O(n^2), so the running time is O(n^2).

Space: O(n^2)

### Union Find Solution

Use union find instead of HashMap to represent graph. When initiating graph using UF.union, check if the two node of an edge isConnected or not, if already connected, then adding another edge will create a cycle so return false. Finally check component num in UF is one or not. Because there is ***a*** valid tree requirement.


```
class Solution {
    public boolean validTree(int n, int[][] edges) {
        UnionFind graph = new UnionFind(n);
        if(initGraph(edges, graph)==false) return false;
        return graph.getComponentNum()==1;
    }
    private boolean initGraph(int[][] edges, UnionFind graph){
        for(int i=0; i<edges.length; i++){
            int first = edges[i][0];
            int second = edges[i][1];
            if(graph.isConnected(first, second))    return false;
            graph.union(first, second);
        }
        return true;
    }
}
class UnionFind {
    private int[] arr;
    private int componentNum;

    public UnionFind(int n){
        this.arr = new int[n];
        for(int i=0; i<arr.length; i++){
            arr[i] = i;
        }
        this.componentNum = n;
    }
    public int root(int i){
        while(arr[i] != i){
            i = arr[i];
        }
        return i;
    }
    public boolean isConnected(int a, int b){
        return root(a) == root(b);
    }
    public void union(int a, int b){
        int aRoot = root(a);
        int bRoot = root(b);
        if(aRoot == bRoot){
            return;
        }else{
            arr[aRoot] = bRoot;
        }
        this.componentNum --;
    }
    public int getComponentNum(){
        return this.componentNum;
    }
}
```

Time: O(nlogn)
Space: O(n)

## 323. Number of Connected Components in an Undirected Graph

### Solution

Solution 1: Union find
Solution 2: DFS and loop, use visitedSet


```
class Solution {
    public int countComponents(int n, int[][] edges) {
        UnionFind graph = new UnionFind(n);
        for(int i=0; i<edges.length; i++)   graph.union(edges[i][0], edges[i][1]);
        return graph.getComponentNum();
    }
}
class UnionFind{
    private int[] arr;
    private int componentNum;
    public UnionFind(int n){
        arr = new int[n];
        for(int i=0; i<arr.length; i++) arr[i] = i;
        componentNum = n;
    }
    public int root(int i){
        while(i!=arr[i])    i = arr[i];
        return i;
    }
    public void union(int a, int b){
        int aRoot = root(a);
        int bRoot = root(b);
        if(aRoot==bRoot)    return;
        else                arr[aRoot] = arr[bRoot];
        componentNum--;
    }
    public int getComponentNum(){
        return componentNum;
    }
}
```

m is edges.length

Time: O(m*logn) = O(n^2*logn)
Space: O(n)

