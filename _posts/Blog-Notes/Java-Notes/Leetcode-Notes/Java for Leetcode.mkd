### List to int[]

```
this.ansList.stream().mapToInt(i->i).toArray();
```

### Clone Map with List inside

```
private Map<String, List<String>> cloneMap(Map<String, List<String>> graph){
    Map<String, List<String>> graphClone = new HashMap<>();
    for(Map.Entry<String, List<String>> entry: graph.entrySet()){
        graphClone.put(entry.getKey(), new ArrayList<String>(entry.getValue()));
    }
    return graphClone;
}
```

### List get and remove

Use remove(index) and add(index, element) instead of remove(element) and add(element). Because `remove(element)` may remove a String with same content. And `add(element)` will add element to the last of list, not the index where it previously lies.

```
graph.get(from).remove(i);
graph.get(from).add(i, dest);
```

### Sort list

```
Collections.sort(destList);
```

### UnionFind class

```
class UnionFind {
    private int[] arr;
    private int componentNum;

    public UnionFind(int n){
        this.arr = new int[n];
        for(int i=0; i<arr.length; i++){
            arr[i] = i;
        }
        this.componentNum = n;
    }
    public int root(int i){
        while(arr[i] != i){
            i = arr[i];
        }
        return i;
    }
    public boolean isConnected(int a, int b){
        return root(a) == root(b);
    }
    public void union(int a, int b){
        int aRoot = root(a);
        int bRoot = root(b);
        if(aRoot == bRoot){
            return;
        }else{
            arr[aRoot] = bRoot;
        }
        this.componentNum --;
    }
    public int getComponentNum(){
        return this.componentNum;
    }
}
```


### Reverse list

`Collections.reverse` do reverse in-place.

```
Collections.reverse(ans.get(i));
```

### set to list

```
new ArrayList<String>(set);
```

### init array

```
return new int[] {0, 0};
```

### init list

```
class Solution {
    Map<TreeNode, Integer> map = new HashMap<>(); // (root of subtree, max money robbed)
    public int rob(TreeNode root) {
        int[] ans = maxArr(root);
        return Math.max(ans[0], ans[1]);
    }
    // ans[0] is max money possible if rob root
    // ans[1] is max money possible if not rob root
    private int[] maxArr(TreeNode root){
        if(root==null)  return new int[] {0, 0};
        int[] ans = new int[2];
        int[] l = maxArr(root.left);
        int[] r = maxArr(root.right);
        ans[0]  = root.val + l[1] + r[1];
        ans[1] = Math.max(l[0], l[1])+Math.max(r[0], r[1]);
        return ans;
    }
}
```

### &

```
opt[i] = (i&1) + opt[i>>>1]; // have to use () for i&1 otherwise + will be executed first
```

### Sort part of an array

Sort `nums` from index i+1(inclusive) to nums.length(exclusive).

```
Arrays.sort(nums, i+1, nums.length);
```
