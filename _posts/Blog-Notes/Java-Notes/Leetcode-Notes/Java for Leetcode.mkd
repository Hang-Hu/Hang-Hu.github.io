### List to int[]

```
this.ansList.stream().mapToInt(i->i).toArray();
```

### Clone Map with List inside

```
private Map<String, List<String>> cloneMap(Map<String, List<String>> graph){
    Map<String, List<String>> graphClone = new HashMap<>();
    for(Map.Entry<String, List<String>> entry: graph.entrySet()){
        graphClone.put(entry.getKey(), new ArrayList<String>(entry.getValue()));
    }
    return graphClone;
}
```

### List get and remove

Use remove(index) and add(index, element) instead of remove(element) and add(element). Because `remove(element)` may remove a String with same content. And `add(element)` will add element to the last of list, not the index where it previously lies.

```
graph.get(from).remove(i);
graph.get(from).add(i, dest);
```

### Sort list

```
Collections.sort(destList);
```

### UnionFind class

```
class UnionFind {
    private int[] arr;
    private int componentNum;

    public UnionFind(int n){
        this.arr = new int[n];
        for(int i=0; i<arr.length; i++){
            arr[i] = i;
        }
        this.componentNum = n;
    }
    public int root(int i){
        while(arr[i] != i){
            i = arr[i];
        }
        return i;
    }
    public boolean isConnected(int a, int b){
        return root(a) == root(b);
    }
    public void union(int a, int b){
        int aRoot = root(a);
        int bRoot = root(b);
        if(aRoot == bRoot){
            return;
        }else{
            arr[aRoot] = bRoot;
        }
        this.componentNum --;
    }
    public int getComponentNum(){
        return this.componentNum;
    }
}
```


### Reverse list

`Collections.reverse` do reverse in-place.

```
Collections.reverse(ans.get(i));
```

### set to list

```
new ArrayList<String>(set);
```