## 937. Reorder Log Files

### Description

```
You have an array of logs.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric identifier.  Then, either:

Each word after the identifier will consist only of lowercase letters, or;
Each word after the identifier will consist only of digits.
We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.

Return the final order of the logs.

 

Example 1:

Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
 

Note:

0 <= logs.length <= 100
3 <= logs[i].length <= 100
logs[i] is guaranteed to have an identifier, and a word after the identifier.
```

### Edge Cases

```
["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo","a2 act car"]
```

The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.

`ties` is when words are the same, then have to use indetifier to order.


### Final Solution - OOP + Sort

Runtime: 2 ms, faster than 99.29% of Java online submissions for Reorder Log Files.
Memory Usage: 37.5 MB, less than 85.29% of Java online submissions for Reorder Log Files.

1. Have a new class `Log(index, identifier, words)`.
2. Use `List<Integer> digitLogs` and `List<Log> letterLogs`
3. Walk through logs to add them into digitLogs and letterLogs
4. sort letterLogs by `Collections.sort` and `new Comparator`, first `l1.words.compareTo(l2.words)`, if same, compare identifier.
5. Add sorted letterLogs into ans, then add digitLogs into ans.



```
class Solution {
    public String[] reorderLogFiles(String[] logs) {
        List<Integer> digitLogs = new ArrayList<>();
        List<Log> letterLogs = new ArrayList<>();
        for(int i=0; i<logs.length; i++){
            int spaceIdx  = logs[i].indexOf(" ");
            String identifier = logs[i].substring(0, spaceIdx);
            String words = logs[i].substring(spaceIdx+1);
            if(words.charAt(0)>='0'&&words.charAt(0)<='9'){
                digitLogs.add(i);
            }else{
                letterLogs.add(new Log(i, identifier, words));            
            }
        }
        Collections.sort(letterLogs, new Comparator<Log>(){
            @Override
            public int compare(Log l1, Log l2){
                int wordsCmp = l1.words.compareTo(l2.words);
                if(wordsCmp!=0) return wordsCmp;
                return l1.identifier.compareTo(l2.identifier);
            }
        });
        String[] ans = new String[logs.length];
        for(int i=0; i<letterLogs.size(); i++) ans[i] = logs[letterLogs.get(i).index];
        for(int i=0; i<digitLogs.size(); i++) ans[i+letterLogs.size()] = logs[digitLogs.get(i)];
        return ans;
    }
}
class Log{
    int index;
    String identifier;
    String words;
    public Log(int index, String identifier, String words){
        this.identifier = identifier;
        this.index = index;
        this.words = words;
    }
}
```

n is logs.length, m is the max length of a log.

Time: O(nlogn)
Space: O(n*m)

## 819. Most Common Word

### Description

```
Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.

Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.

 

Example:

Input: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
Output: "ball"
Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.
 

Note:

1 <= paragraph.length <= 1000.
0 <= banned.length <= 100.
1 <= banned[i].length <= 10.
The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.)
paragraph only consists of letters, spaces, or the punctuation symbols !?',;.
There are no hyphens or hyphenated words.
Words only consist of letters, never apostrophes or other punctuation symbols.
```

### Final Solution - String(Map+Set)

Filter out punctuation and split by one or more spaces. Use set for banned. Use map for (String, frequency).

Walk through words and construct frequency map.

Walk through frequency map, if not in banned set, then compare with max to word with highest frequency.

```
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        String[] words = paragraph.replaceAll("[!?',;.]", " ").split("\\s+");
        Set<String> set = new HashSet<>();
        for(String s: banned) set.add(s);
        Map<String, Integer> map = new HashMap<>(); // (String, frequency)
        for(String w: words){
            w = w.toLowerCase();
            map.put(w, map.getOrDefault(w, 0)+1);
        }
        int max = 0;
        String ans = "";
        for(Map.Entry<String, Integer> entry: map.entrySet()){
            if(entry.getValue()>max && set.contains(entry.getKey())==false){
                max = entry.getValue();
                ans = entry.getKey();
            }
        }
        return ans;
    }
}
```