## 31. Next Permutation

### Description

```
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```

### Solution - single pass and swap


1. find the last consecutive increasing pair (i, i+1), if cannot find this means the whole array is descending, just reverse it.
2. If the pair is last two elements, simply swap them
3. Otherwise the structue will definitely be i+1
                                              /\
                                             i ...
                                                 \

(Since i to i+1 is increasing, and they are the last increasing pair, so everything after it is decreasing)

Then I have to find the last element larger than nums[i], which should be the new number as start, and swap it with i, then sort everything after i to be ascending.


```
class Solution {
    public void nextPermutation(int[] nums) {
        // find the last consecutive increasing pair
        for(int i=nums.length-2; i>=0; i--){
            if(nums[i]<nums[i+1]){
                if(i+1==nums.length-1){
                    swap(nums, i, i+1); // simply swap the pair                
                }else{
                    // find the last element bigger than nums[i]
                    int j = -1;
                    for(j = nums.length-1; j>i; j--){
                        if(nums[j]>nums[i]) break;
                    }
                    swap(nums, i, j);
                    Arrays.sort(nums, i+1, nums.length);
                }
                return;
            }
        }
        // cannot find, all decreasing or keeping same, reverse the array by swap
        for(int i=0; i<nums.length/2; i++){
            swap(nums, i, nums.length-1-i);
        }
    }
    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

## 46. Permutations

### Description

```
Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```


### Solution

Be careful to remove where it was added, also be careful to add to ith index where it was removed.

Use recursion, use possible integers and l as param. Try all integers, remove used one(ith), append it to l, call permute() recusively. After permute(), remove it from l(last one), and add back to integers(ith index).

```
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> l = new ArrayList<>();
        List<Integer> integers = new ArrayList<>();
        for(int n: nums) integers.add(n);
        permute(integers, 0, nums.length, ans, l);
        return ans;
    }
    private void permute(List<Integer> integers, int cur, int len, List<List<Integer>> ans, List<Integer> l){
        if(cur>=len){
            ans.add(new ArrayList<Integer>(l));
            return;
        }
        for(int i=0; i<integers.size(); i++){
            Integer n = integers.get(i);
            l.add(n); // add to the end
            integers.remove(i); // remove ith index
            permute(integers, cur+1, len, ans, l);
            l.remove(l.size()-1); // remove from the end
            integers.add(i, n); // add to ith index
        }
    }
}
```

Time: O(n!)
Space: O(n*n!) = O(n!)

## 47. Permutations II

### Description

```
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

### Final Solution - Backtracking+Recursion

Use Map to store (number, occurrences). Try all possible keys, add to path list, decrease in map, call permuteUnique() recursively, then remove it from path(last one), increase in map.

```
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Map<Integer, Integer> map = new HashMap<>(); // (number, occurrences)
        initMap(map, nums);
        permuteUnique(nums, map, 0, nums.length, ans, new ArrayList<>());
        return ans;
    }
    private void permuteUnique(int[] nums, Map<Integer, Integer> map, int cur, int len, List<List<Integer>> ans, List<Integer> path){
        if(cur>=len){
            ans.add(new ArrayList<>(path));
            return;
        }
        for(Map.Entry<Integer, Integer> e: map.entrySet()){
            if(e.getValue()==0) continue;
            Integer k = e.getKey();
            path.add(k);
            map.put(k, map.get(k)-1);
            permuteUnique(nums, map, cur+1, len, ans, path);
            path.remove(path.size()-1);
            map.put(k, map.get(k)+1);
        }
    }
    private void initMap(Map<Integer, Integer> map, int[] nums){
        for(int n: nums){
            map.put(n, 1+map.getOrDefault(n, 0));
        }
    }
}
```

Time: O(n!)
Space: O(n*n!) = O(n!)