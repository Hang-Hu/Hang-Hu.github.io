---
layout: post
author: Hang Hu
categories: leetcode
tags: Blog Java Leetcode 
cover: 
---
## 937. Reorder Log Files

### Description

```
You have an array of logs.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric identifier.  Then, either:

Each word after the identifier will consist only of lowercase letters, or;
Each word after the identifier will consist only of digits.
We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.

Return the final order of the logs.

 

Example 1:

Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
 

Note:

0 <= logs.length <= 100
3 <= logs[i].length <= 100
logs[i] is guaranteed to have an identifier, and a word after the identifier.
```


### Edge Cases


```
["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo","a2 act car"]
```


The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.


`ties` is when words are the same, then have to use indetifier to order.



### Final Solution - OOP + Sort


Runtime: 2 ms, faster than 99.29% of Java online submissions for Reorder Log Files.

Memory Usage: 37.5 MB, less than 85.29% of Java online submissions for Reorder Log Files.


1. Have a new class `Log(index, identifier, words)`.

2. Use `List<Integer> digitLogs` and `List<Log> letterLogs`

3. Walk through logs to add them into digitLogs and letterLogs

4. sort letterLogs by `Collections.sort` and `new Comparator`, first `l1.words.compareTo(l2.words)`, if same, compare identifier.

5. Add sorted letterLogs into ans, then add digitLogs into ans.




```
class Solution {
    public String[] reorderLogFiles(String[] logs) {
        List<Integer> digitLogs = new ArrayList<>();
        List<Log> letterLogs = new ArrayList<>();
        for(int i=0; i<logs.length; i++){
            int spaceIdx  = logs[i].indexOf(" ");
            String identifier = logs[i].substring(0, spaceIdx);
            String words = logs[i].substring(spaceIdx+1);
            if(words.charAt(0)>='0'&&words.charAt(0)<='9'){
                digitLogs.add(i);
            }else{
                letterLogs.add(new Log(i, identifier, words));            
            }
        }
        Collections.sort(letterLogs, new Comparator<Log>(){
            @Override
            public int compare(Log l1, Log l2){
                int wordsCmp = l1.words.compareTo(l2.words);
                if(wordsCmp!=0) return wordsCmp;
                return l1.identifier.compareTo(l2.identifier);
            }
        });
        String[] ans = new String[logs.length];
        for(int i=0; i<letterLogs.size(); i++) ans[i] = logs[letterLogs.get(i).index];
        for(int i=0; i<digitLogs.size(); i++) ans[i+letterLogs.size()] = logs[digitLogs.get(i)];
        return ans;
    }
}
class Log{
    int index;
    String identifier;
    String words;
    public Log(int index, String identifier, String words){
        this.identifier = identifier;
        this.index = index;
        this.words = words;
    }
}
```


n is logs.length, m is the max length of a log.


Time: O(nlogn)

Space: O(n*m)


## 819. Most Common Word


### Description


```
Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.

Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.

 

Example:

Input: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
Output: "ball"
Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.
 

Note:

1 <= paragraph.length <= 1000.
0 <= banned.length <= 100.
1 <= banned[i].length <= 10.
The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.)
paragraph only consists of letters, spaces, or the punctuation symbols !?',;.
There are no hyphens or hyphenated words.
Words only consist of letters, never apostrophes or other punctuation symbols.
```


### Final Solution - String(Map+Set)


Filter out punctuation and split by one or more spaces. Use set for banned. Use map for (String, frequency).


Walk through words and construct frequency map.


Walk through frequency map, if not in banned set, then compare with max to word with highest frequency.


```
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        String[] words = paragraph.replaceAll("[!?',;.]", " ").split("\\s+");
        Set<String> set = new HashSet<>();
        for(String s: banned) set.add(s);
        Map<String, Integer> map = new HashMap<>(); // (String, frequency)
        for(String w: words){
            w = w.toLowerCase();
            map.put(w, map.getOrDefault(w, 0)+1);
        }
        int max = 0;
        String ans = "";
        for(Map.Entry<String, Integer> entry: map.entrySet()){
            if(entry.getValue()>max && set.contains(entry.getKey())==false){
                max = entry.getValue();
                ans = entry.getKey();
            }
        }
        return ans;
    }
}
```


## 165. Compare Version Numbers


### Description


```
Compare two version numbers version1 and version2.
If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.

The . character does not represent a decimal point and is used to separate number sequences.

For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.

 

Example 1:

Input: version1 = "0.1", version2 = "1.1"
Output: -1
Example 2:

Input: version1 = "1.0.1", version2 = "1"
Output: 1
Example 3:

Input: version1 = "7.5.2.4", version2 = "7.5.3"
Output: -1
Example 4:

Input: version1 = "1.01", version2 = "1.001"
Output: 0
Explanation: Ignoring leading zeroes, both “01” and “001" represent the same number “1”
Example 5:

Input: version1 = "1.0", version2 = "1.0.0"
Output: 0
Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to "0"
 

Note:

Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes.
Version strings do not start or end with dots, and they will not be two consecutive dots.
```


### Final Solution - String + recursion


1. If not empty and not end with dot, append dot

2. Get dot index, if -1 then set version number to 0, otherwise calculate version number before first dot

3. Compare 2 version numbers, if different then return, if same then call compareVersion() recursively with substring.


```
class Solution {
    public int compareVersion(String version1, String version2) {
        if(version1.length()==0 && version2.length()==0) return 0;
        if(version1.length()!=0&&!version1.endsWith(".")) version1 = version1+".";
        if(version2.length()!=0&&!version2.endsWith(".")) version2 = version2+".";
        int dotIdx1 = version1.indexOf(".");
        int dotIdx2 = version2.indexOf(".");
        int v1 = dotIdx1!=-1 ? getVersionNum(version1.substring(0, dotIdx1)) : 0;
        int v2 = dotIdx2!=-1 ? getVersionNum(version2.substring(0, dotIdx2)) : 0;
        if(v1>v2){
            return 1;
        }else if(v1<v2){
            return -1;
        }else{ // ==
            return compareVersion(version1.substring(dotIdx1+1), version2.substring(dotIdx2+1));
        }
    }
    private int getVersionNum(String s){
        return Integer.parseInt(s);
    }
}
```


n1 is version1.length(), n2 is version2.length().


Time: O(max(n1, n2))

Space: O(1)



## 273. Integer to English Words


### Description


```
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.

Example 1:

Input: 123
Output: "One Hundred Twenty Three"
Example 2:

Input: 12345
Output: "Twelve Thousand Three Hundred Forty Five"
Example 3:

Input: 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
Example 4:

Input: 1234567891
Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
```


### Final Solution - String+Recursion


1. Have a map to save 1-9, 10-19, 20-90, 2 zeros(Hundred), 3 zeros(Thousand), 6 zeros(Million), 9 zeros(Billion).

2. Format the num based on 3, and divide it into hundres digit, tens digit, unit digit inside the 3. For example, Format 1234567891 to 1,234,567,891. Take 567 as instance, 5 is hundred digit, 6 is tens digit, 7 is unit digit.

2. call `numberToWords(int num, int numOfZero)` recursively by num/10 and numOfZero+1, num is from 1234 => 123 => 12 => 1, numOfZero is from 0 => 1 => 2 => 3, to show the position of current digit is.

3. Append current digit words after `numberToWords` returns. For 10 digits, append 10 times for 10/11 calls. Divide it into 3 cases: hundres digit, tens digit, unit digit.



Special handling for 10<=x<=19.


In tens digit case, if current digit is 1, append "1" to res, so that unit digit can check if `res` ends with "1". If it does, use 10+currentDigit to get xteen.


Edge case:


1. In the end of unit digit case, if `numOfZero!=0`, which indicates it's the unit digit of 1,234's 1, I have to append Thousand or Million or Billion to whatever unit digit added before. However, be carefully about one special case, `1,000,000` "One Million", where "One Million Thousand" won't work. So if current digit is 0, and `res` ends with "Million " or "Billion ", I shouldn't append "Thousand" or "Million".

2. 0 is not said out, for instance 1000 is "One Thousand" instead of "One Thousand Zero Hundred null Zero", unless it's the only digit(0 is "Zero" not "").



```
class Solution {
    private String[][] numberMap = new String[3][20];
    public Solution(){
        // 1-9
        numberMap[0][1] = "One";
        numberMap[0][2] = "Two";
        numberMap[0][3] = "Three";
        numberMap[0][4] = "Four";
        numberMap[0][5] = "Five";
        numberMap[0][6] = "Six";
        numberMap[0][7] = "Seven";
        numberMap[0][8] = "Eight";
        numberMap[0][9] = "Nine";
        // 10-19
        numberMap[0][10] = "Ten";
        numberMap[0][11] = "Eleven";
        numberMap[0][12] = "Twelve";
        numberMap[0][13] = "Thirteen";
        numberMap[0][14] = "Fourteen";
        numberMap[0][15] = "Fifteen";
        numberMap[0][16] = "Sixteen";
        numberMap[0][17] = "Seventeen";
        numberMap[0][18] = "Eighteen";
        numberMap[0][19] = "Nineteen";
        //20-90
        numberMap[1][2] = "Twenty";
        numberMap[1][3] = "Thirty";
        numberMap[1][4] = "Forty";
        numberMap[1][5] = "Fifty";
        numberMap[1][6] = "Sixty";
        numberMap[1][7] = "Seventy";
        numberMap[1][8] = "Eighty";
        numberMap[1][9] = "Ninety";
        // 3, 6, 9
        numberMap[2][2] = "Hundred";
        numberMap[2][3] = "Thousand";
        numberMap[2][6] = "Million";
        numberMap[2][9] = "Billion";
    }
    public String numberToWords(int num) {
        if(num==0) return "Zero";
        String ans = numberToWords(num, 0);
        return ans.substring(0, ans.length()-1);
    }
    private String numberToWords(int num, int numOfZero){
        if(num==0) return "";
        String res = numberToWords(num/10, numOfZero+1);
        int currentDigit = num%10;
        if(numOfZero%3==2){ // HUNDREDS DIGIT
            if(currentDigit!=0) res+= (numberMap[0][currentDigit]+" "+numberMap[2][2])+" ";
        }else if(numOfZero%3==1){ // TENS DIGIT
            if(currentDigit==1){ // 10<=x<=19
                res += "1";
            }else if(currentDigit!=0){ // 20<=x<=99
                res+=(numberMap[1][currentDigit]+" ");
            }
        }else if(numOfZero%3==0){ // UNITS DIGIT
            if(res.endsWith("1")){ // 10<=x<=19
                res = res.substring(0, res.length()-1)+numberMap[0][10+currentDigit]+" ";
            }else if(currentDigit!=0){ // 0<x<=9
                res += (numberMap[0][currentDigit]+" ");
            }
            // Thousand or Million or Billion
            if(numOfZero!=0){
                if(currentDigit==0 && (res.endsWith("Billion ")||res.endsWith("Million "))){
                    // not add Thousand or Million
                }else{
                    res += (numberMap[2][numOfZero]+" ");
                }
            }
        }
        return res;
    }
}
```


n is number of digits in num.


Time: O(n)

Space: O(n)


## 973. K Closest Points to Origin

### Desription

```
We have a list of points on the plane.  Find the K closest points to the origin (0, 0).

(Here, the distance between two points on a plane is the Euclidean distance.)

You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)

 

Example 1:

Input: points = [[1,3],[-2,2]], K = 1
Output: [[-2,2]]
Explanation: 
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].
Example 2:

Input: points = [[3,3],[5,-1],[-2,4]], K = 2
Output: [[3,3],[-2,4]]
(The answer [[-2,4],[3,3]] would also be accepted.)
 

Note:

1 <= K <= points.length <= 10000
-10000 < points[i][0] < 10000
-10000 < points[i][1] < 10000
```

### First Solution - Sort + OOP

Have new class Point with x, y, dis, sort by dis, return first K point.

Or use Map to replace OOP.

```
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        List<Point> l = new ArrayList<>();
        for(int[] point: points){
            l.add(new Point(point, distance(point[0], point[1])));
        }
        Collections.sort(l, new Comparator<Point>(){
           @Override
            public int compare(Point p1, Point p2){
                return p1.dis-p2.dis;
            }
        });
        int[][] ans = new int[K][2];
        for(int i=0; i<K; i++){
            ans[i] = l.get(i).pos;
        }
        return ans;
    }
    private int distance(int x, int y){
        return x*x+y*y;
    }
}
class Point{
    int[] pos;
    int dis;
    public Point(int[] pos, int dis){
        this.pos = pos;
        this.dis = dis;
    }
}
```

n is number of points.

Time: O(nlog(n))

Space: O(n)

### Second Solution - Simple Sort

As the order to return doesn't, just find the distance of the Kth point, and return points that <= distance of the Kth point.

```
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        int[] disArr = new int[points.length];
        for(int i=0; i<disArr.length; i++){
            disArr[i] = distance(points[i][0], points[i][1]);
        }
        Arrays.sort(disArr);
        int disOfKthPoint = disArr[K-1];
        int ans[][] = new int[K][2];
        int x = 0;
        for(int i=0; i<points.length && x<K; i++){
            if(distance(points[i][0], points[i][1])<=disOfKthPoint){
                ans[x] = points[i];
                x++;
            }
        }
        return ans;
    }
    private int distance(int x, int y){
        return x*x+y*y;
    }
}
```

n is number of points.

Time: O(nlog(n))

Space: O(n)

### Final Solution - kthSmallest(Divide and Conquer)

As order of ans is not required, I can first find the kth smallest distance, and then walk through the array to add those <= kthSmallestDis.

To get kth smallest distance, sorting will cost O(nlogn) time since it even sort the other part that is not useful to get kthSmallest. So actually using divide and conquer to get kthSmallest() first will only cost O(n).

start is inclusive and end is exclusive
kthSmallest(k, start, end):

1. Select last element as pivot, walk through the array to do pivoting

```
<pivot | pivot | >=pivot
L                   R
```

2.

- if k<=|L|, call `kthSmallest(k, start, start+|L|)`
- if k==|L|+1, return pivot
- if k>|L|+1, call `kthSmallest(k-|L|-1, start+|L|+1, end)`

For example,

```
123 | 4 | 56
L         R
```


```
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        int[] disArr = new int[points.length];
        for(int i=0; i<disArr.length; i++){
            disArr[i] = distance(points[i][0], points[i][1]);
        }
        int kthDis = kthSmallest(disArr, K, 0, disArr.length);
        int ans[][] = new int[K][2];
        int x = 0;
        for(int i=0; i<points.length && x<K; i++){
            if(distance(points[i][0], points[i][1])<=kthDis){
                ans[x] = points[i];
                x++;
            }
        }
        return ans;
    }
    // start is inclusive, end is exclusive
    private int kthSmallest(int[] arr, int k, int start, int end){
        int pivot = arr[end-1];
        int i = start;
        for(int j=start; j<end-1; j++){
            if(arr[j]<pivot){
                swap(arr, i, j);
                i++;
            }
        }
        swap(arr, i, end-1);
        int lenOfLeft = i-start;
        if(k<=lenOfLeft){
            return kthSmallest(arr, k, start, start+lenOfLeft);
        }else if(k==lenOfLeft+1){
            return pivot;
        }else{ // k>lenOfLeft+1
            return kthSmallest(arr, k-lenOfLeft-1, start+lenOfLeft+1, end);
        }
    }
    private int distance(int x, int y){
        return x*x+y*y;
    }
    private void swap(int[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```


