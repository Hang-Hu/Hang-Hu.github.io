##

###

### Solution Brute Force

```
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max = 0;
        for(int i=0; i<matrix.length; i++){
            for(int j=0; j<matrix[0].length; j++){
                int maxPossibleLen = Math.min(matrix.length-i, matrix[0].length-j);
                if(matrix[i][j]!='1') continue;
                max = Math.max(max, 1);
                if(maxPossibleLen*maxPossibleLen>max){
                    int len=2;
                    while(len<=maxPossibleLen){
                        if(isSquareForLen2(i, j, len, matrix) || aroundAllOne(i, j, len, matrix)){
                            max = Math.max(max, len*len);
                            len++;
                        }else{
                            break;
                        }
                    }
                }
            }
        }
        return max;
    }
    private boolean isSquareForLen2(int i, int j, int len, char[][] matrix){
        return len==2 && matrix[i][j]=='1' && matrix[i+1][j]=='1' && matrix[i][j+1]=='1' && matrix[i+1][j+1]=='1';
    }
    private boolean aroundAllOne(int x, int y, int len, char[][] matrix){
        for(int j=y; j<y+len; j++){ // right
            if(matrix[x][j]=='0') return false;
        }
        for(int i=x; i<x+len; i++){ // down
            if(matrix[i][y+len-1]=='0') return false;
        }
        for(int j=y+len-1; j>=y; j--){ // left
            if(matrix[x+len-1][j]=='0') return false;
        }
        for(int i=x+len-1; i>=x; i--){ // up
            if(matrix[i][y]=='0') return false;
        }
        return true;
    }
}
```

### Final Solution - DP

`opt(i, j)` is the side length of largest square whose bottom right corner reside in position (i, j).

For example,

```
matrix  opt
011     011
111 =>  112
011     012
```

1. If matrix[i][j] is '0', opt(i, j) is 0.
2. If matrix[i][j] is '1' but i-1<0 || j-1<0, opt(i, j) is 1.
3. If matrix[i][j] is '1' and i-1>=0 and j-1>=0, opt(i, j) = 1+min(opt(i-1, j), opt(i, j-1), opt(i-1, j-1))


```
(i-1, j-1)  (i-1, j)
(i, j-1)    (i, j)
```


```
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(matrix.length==0) return 0;
        int[][] opt = new int[matrix.length][matrix[0].length];
        for(int i=0; i<opt.length; i++){
            for(int j=0; j<opt[0].length; j++){
                if(matrix[i][j]=='1'){
                    if(i-1<0 || j-1<0) opt[i][j] = 1;
                    else opt[i][j] = 1+min(opt[i][j-1], opt[i-1][j], opt[i-1][j-1]);
                }
            }
        }
        int max = 0;
        for(int i=0; i<opt.length; i++){
            for(int j=0; j<opt[0].length; j++){
                max = Math.max(max, opt[i][j]);
            }
        }
        return max*max;
    }
    private int min(int a, int b, int c){
        return Math.min(Math.min(a, b), c);
    }
}
```