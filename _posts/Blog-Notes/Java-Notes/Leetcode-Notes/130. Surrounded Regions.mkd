## Description

```
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
Explanation:

Surrounded regions shouldnâ€™t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
```

## Union Find Solution

Just like percolation, use UF to represent the board. Check if connected to the boarder by uf.isConnected(node, root). Root is a virtual node connecting all boarders, put it in last node of UF's arr.

In initGraph, have to union boaders with root. If a node is `O` then I check and union `O` only in right and bottom.(Because `O` in top and left has been unioned with current already).

In flip, if a node is `O` and not connected to root, then flip it.

```
class Solution {
    public void solve(char[][] board) {
        if(board.length==0) return;
        int len = board.length * board[0].length;
        UnionFind graph = new UnionFind(len+1);
        initGraph(graph, board, len);
        flip(graph, board, len);
    }
    private void flip(UnionFind graph, char[][] board, int root){
        for(int i=0; i<board.length; i++){
            for(int j=0; j<board[0].length; j++){
                if(board[i][j]=='O' && (graph.isConnected(calcIndex(i, j, board), root)==false)){
                    board[i][j] = 'X';
                }
            }
        }
    }
    private void initGraph(UnionFind graph, char[][] board, int root){
        for(int i=0; i<board.length; i++){
            for(int j=0; j<board[0].length; j++){
                // union first and last row, first and last column to a virtual node(last element in UF arr, name it root)
                if(i==0||i==board.length-1||j==0||j==board[0].length-1) graph.union(calcIndex(i, j, board), root);
                // union O with right and bottom O
                if(board[i][j]=='O'){
                    if(j+1<board[0].length && board[i][j+1]=='O')  graph.union(calcIndex(i, j, board), calcIndex(i, j+1, board)); // check right
                    if(i+1<board.length && board[i+1][j]=='O')  graph.union(calcIndex(i, j, board), calcIndex(i+1, j, board)); // check bottom
                }
            }
        }
    }
    private int calcIndex(int x, int y, char[][] board){
        return x*board[0].length+y;
    }
}
class UnionFind{
    private int[] arr;
    public UnionFind(int len){
        arr = new int[len];
        for(int i=0; i<arr.length; i++){
            arr[i] = i;
        }
    }
    private int root(int i){
        while(arr[i]!=i){
            i = arr[i];
        }
        return i;
    }
    public boolean isConnected(int a, int b){
        return root(a) == root(b);
    }
    public void union(int a, int b){
        int aRoot = root(a);
        int bRoot = root(b);
        if(aRoot==bRoot)    return;
        else                arr[aRoot] = bRoot;
    }
}
```

m is board.length, n is board[0].length.

Time: O(mn*log(mn))

Space: O(m*n)


## DFS Solution - Final Solution

Loop board, if find a `O` then do dfs, if find a node that is border, then pass border=true to all following recursions, in last recursion I have to return border boolean. And when returning back, if node is `O` and `border` is false, flip it to X.