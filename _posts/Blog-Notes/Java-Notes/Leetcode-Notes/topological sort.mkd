## 269. Alien Dictionary

### Description

```
There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

Example 1:

Input:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]

Output: "wertf"
Example 2:

Input:
[
  "z",
  "x"
]

Output: "zx"
Example 3:

Input:
[
  "z",
  "x",
  "z"
] 

Output: "" 

Explanation: The order is invalid, so return "".
Note:

You may assume all letters are in lowercase.
You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.
If the order is invalid, return an empty string.
There may be multiple valid order of letters, return any one of them is fine.
```

### DFS Solution(slow but less memory)

DFS and append node to return to the start of answer.

```
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, List<Character>> graph = new HashMap<>();
        initGraph(words, graph);
        List<Character> path = new ArrayList<>();
        // have a visited for all sources, when enconter this one, don't continue dfs with this neighbor, but don't need to report false as cycle.
        Set<Character> visitedAllSources = new HashSet<>();
        for(char c: graph.keySet()){
            if(visitedAllSources.contains(c)==false){
                Set<Character> visited = new HashSet<>();
                if(dfs(c, graph, path, visited, visitedAllSources)==false)    return "";    
            }
        }
        Set<Character> charSet = getCharSet(words);
        addRemainingNode(charSet, path);
        return path.stream().map(String::valueOf).collect(Collectors.joining());
    }
    private Set<Character> getCharSet(String[] words){
        Set<Character> charSet = new HashSet<>();
        for(int i=0; i<words.length; i++){
            for(int j=0; j<words[i].length(); j++){
                charSet.add(words[i].charAt(j));
            }
        }
        return charSet;
    } 
    private void addRemainingNode(Set<Character> charSet, List<Character> path){
        for(char c: charSet){
            if(path.contains(c)==false) path.add(c);
        }
    }
    //dfs to get tp order
    private boolean dfs(char node, Map<Character, List<Character>> graph, List<Character> path, Set<Character> visited, Set<Character> visitedAllSources){
        visited.add(node);
        visitedAllSources.add(node);
        List<Character> neighbors = graph.get(node);
        if(neighbors!=null){
            for(char neighbor: neighbors){
                if(visited.contains(neighbor)) return false;
                if(visitedAllSources.contains(neighbor)) continue;
                if(dfs(neighbor, graph, path, visited, visitedAllSources)==false) return false;
                visited.remove(neighbor);
            }    
        }
        path.add(0, node);
        return true;
    }
    private void initGraph(String[] words, Map<Character, List<Character>> graph){
        if(words.length>0){
            for(int i=0; i<words.length-1; i++){
                char firstChar = words[i].charAt(0);
                char secondChar = words[i+1].charAt(0);
                if(firstChar==secondChar){
                    if(words[i].length()>1 && words[i+1].length()>1){
                        initGraph(new String[] {words[i].substring(1), words[i+1].substring(1)}, graph);
                    }
                }else{
                    if(graph.containsKey(firstChar)){
                        graph.get(firstChar).add(secondChar);
                    }else{
                        graph.put(firstChar, new ArrayList<Character>(){{add(secondChar);}});
                    }
                }
            }
        }
    }
}
```

m is the length of longest word, n is the words.length

Time: O(m*n)

initGraph is O(m*n), dfs is O(n) since it's dp order, no cycle or return when find there is a cycle, that means edges number to be visited is n-1 instead of n^2. `getCharSet` is O(n*m). `addRemainingNode` is O(n)

Space: O(m*n)

```
Map<Character, List<Character>> graph = new HashMap<>(); O(m*n)
List<Character> path = new ArrayList<>(); O(m*n)
Set<Character> visitedAllSources = new HashSet<>(); O(m*n)
Set<Character> visited = new HashSet<>(); O(m*n)
Set<Character> charSet = getCharSet(words); O(m*n)
```


The time in github slower than 99%, and I found it's due to `path.stream().map(String::valueOf).collect(Collectors.joining());`. As I tried, even not use `boolean[]`, simply use `String` to replace `List<Character> path` will beats 100% submissions.

### Final Solution(use StringBuilder and boolean array)

StringBuilder is used to replace `path.stream().map(String::valueOf).collect(Collectors.joining())`.

Recursively init graph. If char at 0 of 2 lines the same, send sub of two to initGraph, ow firstChar points to second. DFS with all chars in dict, using path(have to remove node when return) and visitedAllRounds. If encounter same node in path, cycle detected. If encounter same node in visitedAllRounds, skip that node. When the all neighbors of node visited, add it to sb, finially reverse sb.


```
class Solution {
    public String alienOrder(String[] words) {
        boolean[][] graph = new boolean[26][26];
        initGraph(words, graph);
        StringBuilder sb = new StringBuilder();
        // have visitedAllRounds for all characters, when enconter this one, don't continue dfs with this neighbor, but don't need to report false as cycle.
        boolean[] visitedAllRounds = new boolean[26];
        boolean[] chars = getChars(words);
        for(int i=0; i<26; i++){
            if(chars[i]==true && visitedAllRounds[i]==false){
                boolean[] path = new boolean[26];
                if(dfs(i, graph, sb, path, visitedAllRounds)==false)    return "";    
            }
        }
        return sb.reverse().toString();
    }
    private boolean[] getChars(String[] words){
        boolean[] chars = new boolean[26];
        for(int i=0; i<words.length; i++){
            for(int j=0; j<words[i].length(); j++){
                chars[words[i].charAt(j)-'a'] = true;
            }
        }
        return chars;
    } 
    //dfs to get tp order
    private boolean dfs(int node, boolean[][] graph, StringBuilder sb, boolean[] path, boolean[] visitedAllRounds){
        path[node] = true;
        visitedAllRounds[node] = true;
        for(int i=0; graph[node]!=null&&i<graph[node].length; i++){
            if(graph[node][i]==true){
                if(path[i]==true) return false;
                if(visitedAllRounds[i]==true) continue;
                if(dfs(i, graph, sb, path, visitedAllRounds)==false) return false;
                path[i] = false;
            }
        }    
        sb.append((char)('a'+node));
        return true;
    }
    private void initGraph(String[] words, boolean[][] graph){
        if(words.length>0){
            for(int i=0; i<words.length-1; i++){
                int firstChar = words[i].charAt(0)-'a';
                int secondChar = words[i+1].charAt(0)-'a';
                if(firstChar==secondChar){
                    if(words[i].length()>1 && words[i+1].length()>1){
                        initGraph(new String[] {words[i].substring(1), words[i+1].substring(1)}, graph);
                    }
                }else{
                    if(graph[firstChar]==null){
                        graph[firstChar] = new boolean[26];
                    }
                    graph[firstChar][secondChar] = true;
                }
            }
        }
    }
}
```

The same time and space complexity as previous one.

m is the length of longest word, n is the words.length

Time: O(m*n)
Space: O(m*n)
