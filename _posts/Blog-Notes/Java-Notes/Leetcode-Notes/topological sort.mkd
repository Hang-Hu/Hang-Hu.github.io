## 269. Alien Dictionary

### Description

```
There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

Example 1:

Input:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]

Output: "wertf"
Example 2:

Input:
[
  "z",
  "x"
]

Output: "zx"
Example 3:

Input:
[
  "z",
  "x",
  "z"
] 

Output: "" 

Explanation: The order is invalid, so return "".
Note:

You may assume all letters are in lowercase.
You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.
If the order is invalid, return an empty string.
There may be multiple valid order of letters, return any one of them is fine.
```

### DFS Solution(slow but less memory)

DFS and append node to return to the start of answer.

```
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, List<Character>> graph = new HashMap<>();
        initGraph(words, graph);
        List<Character> path = new ArrayList<>();
        // have a visited for all sources, when enconter this one, don't continue dfs with this neighbor, but don't need to report false as cycle.
        Set<Character> visitedAllSources = new HashSet<>();
        for(char c: graph.keySet()){
            if(visitedAllSources.contains(c)==false){
                Set<Character> visited = new HashSet<>();
                if(dfs(c, graph, path, visited, visitedAllSources)==false)    return "";    
            }
        }
        Set<Character> charSet = getCharSet(words);
        addRemainingNode(charSet, path);
        return path.stream().map(String::valueOf).collect(Collectors.joining());
    }
    private Set<Character> getCharSet(String[] words){
        Set<Character> charSet = new HashSet<>();
        for(int i=0; i<words.length; i++){
            for(int j=0; j<words[i].length(); j++){
                charSet.add(words[i].charAt(j));
            }
        }
        return charSet;
    } 
    private void addRemainingNode(Set<Character> charSet, List<Character> path){
        for(char c: charSet){
            if(path.contains(c)==false) path.add(c);
        }
    }
    //dfs to get tp order
    private boolean dfs(char node, Map<Character, List<Character>> graph, List<Character> path, Set<Character> visited, Set<Character> visitedAllSources){
        visited.add(node);
        visitedAllSources.add(node);
        List<Character> neighbors = graph.get(node);
        if(neighbors!=null){
            for(char neighbor: neighbors){
                if(visited.contains(neighbor)) return false;
                if(visitedAllSources.contains(neighbor)) continue;
                if(dfs(neighbor, graph, path, visited, visitedAllSources)==false) return false;
                visited.remove(neighbor);
            }    
        }
        path.add(0, node);
        return true;
    }
    private void initGraph(String[] words, Map<Character, List<Character>> graph){
        if(words.length>0){
            for(int i=0; i<words.length-1; i++){
                char firstChar = words[i].charAt(0);
                char secondChar = words[i+1].charAt(0);
                if(firstChar==secondChar){
                    if(words[i].length()>1 && words[i+1].length()>1){
                        initGraph(new String[] {words[i].substring(1), words[i+1].substring(1)}, graph);
                    }
                }else{
                    if(graph.containsKey(firstChar)){
                        graph.get(firstChar).add(secondChar);
                    }else{
                        graph.put(firstChar, new ArrayList<Character>(){{add(secondChar);}});
                    }
                }
            }
        }
    }
}
```

m is the length of longest word, n is the words.length


Time: O(m*n)

initGraph is O(m*n), dfs is O(n) since it's dp order, no cycle or return when find there is a cycle, that means edges number to be visited is n-1 instead of n^2. `getCharSet` is O(n*m). `addRemainingNode` is O(n)

Space: O(m*n)

```
Map<Character, List<Character>> graph = new HashMap<>(); O(m*n)
List<Character> path = new ArrayList<>(); O(m*n)
Set<Character> visitedAllSources = new HashSet<>(); O(m*n)
Set<Character> visited = new HashSet<>(); O(m*n)
Set<Character> charSet = getCharSet(words); O(m*n)
```


The time in github slower than 99%, and I found it's due to `path.stream().map(String::valueOf).collect(Collectors.joining());`.

### In/Out Degree Solution

