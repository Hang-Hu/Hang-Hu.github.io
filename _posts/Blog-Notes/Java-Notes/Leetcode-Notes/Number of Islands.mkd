##

## 305. Number of Islands II


### Solution

```
class Solution {
    public List<Integer> numIslands2(int m, int n, int[][] positions) {
        // UnionFind graph = new UnionFind(m*n);
        int[][] graph = new int[m][n];
        List<Integer> ans = new ArrayList<>();
        for(int i=0; i<positions.length; i++){
            ans.add(addLand(graph, positions[i][0], positions[i][1]));
        }
        for(int i=1; i<ans.size(); i++){
            ans.set(i, ans.get(i)+ans.get(i-1));
        }
        return ans;
    }
    /*
Won't work for
2
2
[[0,0],[1,1],[0,1]]

TODO: use union find
    */
    // return either +1 or +0
    private int addLand(int[][] graph, int x, int y){
        int canConnectNum = 0;
        graph[x][y] = 1;
        if(x-1 >=0 && graph[x-1][y]==1)                 canConnectNum++;
        if(x+1 < graph.length && graph[x+1][y]==1)      canConnectNum++;
        if(y-1 >=0 && graph[x][y-1]==1)                 canConnectNum++;
        if(y+1 < graph[0].length && graph[x][y+1]==1)   canConnectNum++;
        return canConnect==true?0:1;
    }
}
class UnionFind{
    private int[] arr;
    public UnionFind(int len){
        this.arr = new int[len];
        for(int i=0; i<arr.length; i++){
            arr[i] = i;
        }
    }
    private int root(int i){
        while(arr[i]!=i){
            i = arr[i];
        }
        return i;
    }
    public boolean isConnected(int a, int b){
        return root(a)==root(b);
    }
    public void union(int a, int b){
        int aRoot = root(a);
        int bRoot = root(b);
        if(aRoot==bRoot)    return;
        else                arr[aRoot] = bRoot;
    }
}
```