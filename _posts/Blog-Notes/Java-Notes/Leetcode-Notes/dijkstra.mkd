## 743. Network Delay Time

### Description

```
There are N network nodes, labelled 1 to N.

Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.

Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.

 

Example 1:



Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2
Output: 2
 

Note:

N will be in the range [1, 100].
K will be in the range [1, N].
The length of times will be in the range [1, 6000].
All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 0 <= w <= 100.

```

### Non heap solution

```
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        Set<Integer> s = new HashSet<>();
        int[] distance = new int[N+1]; // distance from start node K to each node
        Map<Integer, List<Node>> graph = new HashMap<>(); // (node, List of (neighbor, distance))
        initMap(graph, times);
        initDistance(distance);
        distance[K] = 0; // distance(start, start) = 0
        while(s.size()<N){ // until |S| == |V|
            int node = nodeNotFromSWithMINDIS(distance, s); // node not from S with min distance(start, node)
            if(node==-1) return -1; // cannot find a node not max distance, exist unreachable node from start node
            s.add(node);
            // update distance from start to each neighbor of selected one
            List<Node> neighbors = graph.get(node);
            for(int i=0; neighbors!=null && i<neighbors.size(); i++){
                Node neighbor = neighbors.get(i);
                distance[neighbor.val] = Math.min(distance[neighbor.val], distance[node]+neighbor.distance);
            }
        }
        // get the max delay, which is max of distance from start to each node
        int max = 0; // distance from start to start is 0
        for(int d: distance){
            if(d!=Integer.MAX_VALUE && d>max) max = d;
        }
        return max;
    }
    private void initDistance(int[] distance){
        for(int i=0; i<distance.length; i++){
            distance[i] = Integer.MAX_VALUE;
        }
    }
    private void initMap(Map<Integer, List<Node>> graph, int[][] times){
        for(int i=0; i<times.length; i++){
            if(graph.containsKey(times[i][0])==false) graph.put(times[i][0], new ArrayList<Node>());
            graph.get(times[i][0]).add(new Node(times[i][1], times[i][2]));
        }
    }
    private int nodeNotFromSWithMINDIS(int[] distance, Set<Integer> s){
        int min = Integer.MAX_VALUE;
        int node = -1;
        for(int i=1; i<distance.length; i++){
            if(s.contains(i)==false && distance[i]<min){
                min = distance[i];
                node = i;
            }
        }
        return node;
    }
}
class Node{
    int val;
    int distance;
    public Node(int val, int distance){
        this.val = val;
        this.distance = distance;
    }
}
```

m is the number of edges and n is the number of nodes.

Time: O((m+n)*n) = O(m*n)

Space: O(m+n) = O(m)


### heap solution - Dijkstra+MIN Heap

Traverse `distance` to find the min distance not from S, it takes O(n), to save it, use heap which only take O(logn) to select each min distance.

Use `PriorityQueue` for min heap, `Set` for set S, `Map<Integer, List<Node>> graph` to have the graph.

Loop until all nodes added into `S`.
1. get the node with min `d(start, node)`.
2. update neighbor d of this node. Here unlike non heap solution, since java `PriorityQueue` doesn't provice update inner node and adjust method. As long as neighbor hasn't been added into set S, I will create a new Node with its value and use `d(start, node)+len(node, neighbor)` as distance to add into heap.

Since each node will be added into set S once, and add neighbors not in S, every edge can be added into heap only once. The time complexity for `poll` and `add` will be O(logm)


```
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        Set<Integer> s = new HashSet<>();
        // Use a min heap for distance from start to node
        Queue<Node> distanceHeap = new PriorityQueue<>(new Comparator<Node>(){
            @Override
            public int compare(Node n1, Node n2){
                return n1.distance - n2.distance;
            }
        });
        Map<Integer, List<Node>> graph = new HashMap<>(); // (node, List of (neighbor, distance from node to neighbor))
        initMap(graph, times);
        distanceHeap.add(new Node(K, 0)); // d(start, start)==0
        int max = 0; // d(start, start) is 0
        while(s.size()<N){ // until |S| == |V|
            // use the min d not from S
            Node node = distanceHeap.poll(); // node definitely not in S, otherwise polled before
            if(node==null) return -1; // cannot find a non-S node, exist unreachable node from start node
            max = Math.max(max, node.distance); // d of the pulled is the min d from start to node
            s.add(node.val);
            // update distance from start to each neighbor of selected one
            List<Node> neighbors = graph.get(node.val);
            for(int i=0; neighbors!=null && i<neighbors.size(); i++){
                Node neighbor = neighbors.get(i);
                // add neighbor with new distance when neighbor not from S
                if(s.contains(neighbor.val)==false) distanceHeap.add(new Node(neighbor.val, node.distance+neighbor.distance));
            }
        }
        return max;
    }
    private void initMap(Map<Integer, List<Node>> graph, int[][] times){
        for(int i=0; i<times.length; i++){
            if(graph.containsKey(times[i][0])==false) graph.put(times[i][0], new ArrayList<Node>());
            graph.get(times[i][0]).add(new Node(times[i][1], times[i][2]));
        }
    }
}
class Node{
    int val;
    int distance;
    public Node(int val, int distance){
        this.val = val;
        this.distance = distance;
    }
}
```

m is the number of edges, and n is the number of nodes, which is N.

Time: O((m+n)*logm)=O(mlogm)

Space: O(m+n)=O(m)

## 787. Cheapest Flights Within K Stops

### Solution - Improved Bellman Ford

1. Init 0th layer d(start, node)=max, d(start, start)=0.
2. In Bellman Ford, repeat |V|-1 times because longest path have |V|-1 edges based on cycle definition. Here repeat K+2 times so that at most K stops, 2 is for start and dest node, i==0 is for init where only start is accessible.
3. In loop I am not using in place update to d(Bellman ford uses in place), because I want to strictly add one more layer per iteration. I cannot update based on current layer, must update based on `i-1` layer.
4. init current layer using `i-1`th d
5. for all edges (u, v)(for all flight (u, v)), if d(u)!=MAX(to avoid add MAX with value and then overflow) and `d(u)+len(u, v)<d(v)`, update `d(v)`.
6. return `d[last_layer][dest]`, if it's MAX return -1, otherwise return it directly.

```
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        int[][] distance = new int[K+2][n];
        init(distance, src);
        // repeat K+2 times to make sure K stops
        for(int i=1; i<K+2; i++){
            for(int j=0; j<distance[0].length; j++) distance[i][j] = distance[i-1][j];
            for(int[] flight: flights){
                if(distance[i-1][flight[0]]!=Integer.MAX_VALUE) distance[i][flight[1]] = Math.min(distance[i][flight[1]], distance[i-1][flight[0]]+flight[2]);
            }
        }
        int ans = distance[distance.length-1][dst];
        return ans==Integer.MAX_VALUE ? -1 : ans;
    }
    private void init(int[][] distance, int src){
        for(int j=0; j<distance[0].length; j++){
            if(j==src) distance[0][src] = 0;
            else distance[0][j] = Integer.MAX_VALUE;
        }
    }
    
}
```


n is number of nodes, m is number of edges(flights), K is max number of stops.

Time: O(K*(n+m)) = O(K*m)

Space: O(K*n)

Space can be improved because we only need d of `i-1` and `i`. Using them alternatively would work. It can be improved to O(n)

### Final Solution - Dijkstra+min heap

Use dijkstra and min heap just like final solution of 743. Network Delay Time, the only difference is that `preNodeNum` added into class `Node`, which is used to track number of nodes prior to current node(parent, parant's parant, ..., src). If `node.preNodeNum>K`, node's neighbors will definitely exceed stop limit, cannot update neighbor and add to heap.


```
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        Set<Integer> s = new HashSet<>();
        Map<Integer, List<Node>> graph = new HashMap<>();
        initGraph(graph, flights);
        Queue<Node> distanceMinHeap = new PriorityQueue<>(new Comparator<Node>(){
            @Override
            public int compare(Node n1, Node n2){
                return n1.distance-n2.distance;
            }
        });
        distanceMinHeap.add(new Node(src, 0, 0)); // d(src, src)=0
        while(s.size()<n){
            Node node = distanceMinHeap.poll();
            if(node==null) return -1;
            if(node.val==dst) return node.distance;
            s.add(node.val);
            if(node.preNodeNum>K) continue; // its neighbor will exceed stop limit, cannot add, try next node
            // update neighbors of node and add into heap
            List<Node> neighbors = graph.get(node.val);
            for(int i=0; neighbors!=null && i<neighbors.size(); i++){
                Node neighbor = neighbors.get(i);
                if(s.contains(neighbor)==false) distanceMinHeap.add(new Node(neighbor.val, node.distance+neighbor.distance, node.preNodeNum+1));
            }
        }
        return -1;
    }
    private void initGraph(Map<Integer, List<Node>> graph, int[][] flights){
        for(int[] flight: flights){
            int src = flight[0];
            if(graph.containsKey(src)==false) graph.put(src, new ArrayList<Node>());
            graph.get(src).add(new Node(flight[1], flight[2], -2));
        }
    }
}
class Node{
    int val;
    int distance;
    // if preNodeNum==-2, then distance is from connected to node, ow d is from src to node
    // if preNodeNum==-1, then distance is MAX
    int preNodeNum;
    public Node(int val, int distance, int preNodeNum){
        this.val = val;
        this.distance = distance;
        this.preNodeNum = preNodeNum;
    }
}
```

m is number of edges and n is number of nodes.

Time: O((m+n)*logm)=O(mlogm)

Space: O(m+n)=O(m)


## 882. Reachable Nodes In Subdivided Graph

### First Solution - DFS(TLE)

Problem is duplicate visit of same edge.

When 0->1 is 10, 0->2 is 1, 2->1 is 1, M is 11, then even it's second time to visit 1, I have to continue so that I can visit nodes in 1->3.

```
 0
/  \
1--2
|
3
```

When 0->1 is 4, 0->2 is 1, 2->1 is 1, 1->3 is 1, M is 8. 

First visit 1->3: 0->1->3->4
Second visit 1->3: 0->2->1->3->4

Even it's the second time visiting edge 1->3 in full, I have to continue to let more nodes in 3->4 can be visited. So the important thing is to make sure dis(0, 3) is shortest so that more nodes in 3->4 can be visited. The DFS version visit edges repeatedly to solve the problem, causing TLE.

```
 0
/  \
1--2
|
3
|
4
```

```
class Solution {
    public int reachableNodes(int[][] edges, int M, int N) {
        if(M==0) return 0;
        boolean[] nodeVisited = new boolean[N];
        int[][] visitedNodesInEdge = new int[N][N];
        Map<Integer, List<NodeDis>> graph = new HashMap<>();
        init(graph, edges);
        dfs(graph, 0, M, nodeVisited, visitedNodesInEdge, -1);
        int ans = 0;
        for(int[] edge: edges){
            int i = edge[0];
            int j = edge[1];
            // System.out.println(i+" "+j+" "+visitedNodesInEdge[i][j]+" "+visitedNodesInEdge[j][i]);

            ans += Math.min(visitedNodesInEdge[i][j]+visitedNodesInEdge[j][i], edge[2]);
        }
        System.out.println(ans);
        // start from 1, in case 0 is also visited
        for(int i=1; i<N; i++){
            if(nodeVisited[i]) ans++;
        }
        // System.out.println(ans);
        return ans+1;
    }
    private void dfs(Map<Integer, List<NodeDis>> graph, int nodeVal, int remainingNodeNum, boolean[] nodeVisited, int[][] visitedNodesInEdge, int parent){
        List<NodeDis> neighbors = graph.get(nodeVal);
        if(neighbors!=null){
            for(NodeDis neighbor: neighbors){
                // System.out.println("Start: "+nodeVal+" "+neighbor);
                if(neighbor.val==parent) continue;
                // if(visitedNodesInEdge[nodeVal][neighbor.val]==neighbor.dis) continue;
                // }else{
                if(remainingNodeNum-neighbor.dis>1){ // node will be visited and next edge
                    visitedNodesInEdge[nodeVal][neighbor.val] = neighbor.dis;
                    nodeVisited[neighbor.val] = true;
                    dfs(graph, neighbor.val, remainingNodeNum-neighbor.dis-1, nodeVisited, visitedNodesInEdge, nodeVal);
                }else if(remainingNodeNum-neighbor.dis==1){ // node will be visited
                    visitedNodesInEdge[nodeVal][neighbor.val] = neighbor.dis;
                    nodeVisited[neighbor.val] = true;
                }else{ // node won't be visited
                    // in case this is second visit of the edge a is shorter
                    if(remainingNodeNum>visitedNodesInEdge[nodeVal][neighbor.val]) visitedNodesInEdge[nodeVal][neighbor.val] = remainingNodeNum;
                }
                // }
                // System.out.println(nodeVal+" "+neighbor.val+" "+visitedNodesInEdge[nodeVal][neighbor.val]);
            }
        }
    }
    private void init(Map<Integer, List<NodeDis>> graph, int[][] edges){
        for(int[] edge: edges){
            if(graph.containsKey(edge[0])==false) graph.put(edge[0], new ArrayList<NodeDis>());
            graph.get(edge[0]).add(new NodeDis(edge[1], edge[2]));
            if(graph.containsKey(edge[1])==false) graph.put(edge[1], new ArrayList<NodeDis>());
            graph.get(edge[1]).add(new NodeDis(edge[0], edge[2]));
        }
    }
}
class NodeDis{
    int val;
    int dis;
    public NodeDis(int val, int dis){
        this.val = val;
        this.dis = dis;
    }
    @Override
    public String toString(){
        return "("+val+" "+dis+")";
    }
}
```

## 505. The Maze II

### Description

[the-maze-ii](https://leetcode.com/problems/the-maze-ii/)

### First Solution - DFS

Improve upon DFS solution of Maze I. Previously I used Set to avoid same slot that has been visited before. Here since we want shortest distance, same slot is good as long as the distance to this slot is smaller than previous distance. So I have a Map for `(position, min distance from start to this position)`, if current distance >= record, return MAX, otherwise put this distance in map.

```
class Solution {
    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        Map<Integer, Integer> map = new HashMap<>(); // (position, min distance from start to this position)
        int res = dfs(maze, start, destination, 0, map);
        return res==Integer.MAX_VALUE ? -1 : res;
    }
    private int dfs(int[][] maze, int[] cur, int[] dst, int distance, Map<Integer, Integer> map){
        int i=cur[0], j=cur[1];
        if(i==dst[0] && j==dst[1]) return distance;
        int pos = position(i, j, maze[0].length);
        if(map.containsKey(pos) && map.get(pos)<=distance) return Integer.MAX_VALUE;
        map.put(pos, distance);
        int ans = Integer.MAX_VALUE;
        //left
        int jL = j;
        while(jL>0 && maze[i][jL-1]==0) jL--;
        if(jL!=j) ans = Math.min(ans, dfs(maze, new int[]{i, jL}, dst, distance+j-jL, map));
        // right
        int jR = j;
        while(jR<maze[0].length-1 && maze[i][jR+1]==0) jR++;
        if(jR!=j) ans = Math.min(ans, dfs(maze, new int[]{i, jR}, dst, distance+jR-j, map));
        // up
        int iU = i;
        while(iU>0 && maze[iU-1][j]==0) iU--;
        if(iU!=i) ans = Math.min(ans, dfs(maze, new int[]{iU, j}, dst, distance+i-iU, map));
        // down
        int iD = i;
        while(iD<maze.length-1 && maze[iD+1][j]==0) iD++;
        if(iD!=i) ans = Math.min(ans, dfs(maze, new int[]{iD, j}, dst, distance+iD-i, map));
        return ans;
    }
    private int position(int i, int j, int colLen){
        return i*colLen+j;
    }
}
```

