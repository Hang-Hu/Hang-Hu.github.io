## 743. Network Delay Time

### Description

```
There are N network nodes, labelled 1 to N.

Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.

Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.

 

Example 1:



Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2
Output: 2
 

Note:

N will be in the range [1, 100].
K will be in the range [1, N].
The length of times will be in the range [1, 6000].
All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 0 <= w <= 100.

```

### Non heap solution

```
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        Set<Integer> s = new HashSet<>();
        int[] distance = new int[N+1]; // distance from start node K to each node
        Map<Integer, List<Node>> graph = new HashMap<>(); // (node, List of (neighbor, distance))
        initMap(graph, times);
        initDistance(distance);
        distance[K] = 0; // distance(start, start) = 0
        while(s.size()<N){ // until |S| == |V|
            int node = nodeNotFromSWithMINDIS(distance, s); // node not from S with min distance(start, node)
            if(node==-1) return -1; // cannot find a node not max distance, exist unreachable node from start node
            s.add(node);
            // update distance from start to each neighbor of selected one
            List<Node> neighbors = graph.get(node);
            for(int i=0; neighbors!=null && i<neighbors.size(); i++){
                Node neighbor = neighbors.get(i);
                distance[neighbor.val] = Math.min(distance[neighbor.val], distance[node]+neighbor.distance);
            }
        }
        // get the max delay, which is max of distance from start to each node
        int max = 0; // distance from start to start is 0
        for(int d: distance){
            if(d!=Integer.MAX_VALUE && d>max) max = d;
        }
        return max;
    }
    private void initDistance(int[] distance){
        for(int i=0; i<distance.length; i++){
            distance[i] = Integer.MAX_VALUE;
        }
    }
    private void initMap(Map<Integer, List<Node>> graph, int[][] times){
        for(int i=0; i<times.length; i++){
            if(graph.containsKey(times[i][0])==false) graph.put(times[i][0], new ArrayList<Node>());
            graph.get(times[i][0]).add(new Node(times[i][1], times[i][2]));
        }
    }
    private int nodeNotFromSWithMINDIS(int[] distance, Set<Integer> s){
        int min = Integer.MAX_VALUE;
        int node = -1;
        for(int i=1; i<distance.length; i++){
            if(s.contains(i)==false && distance[i]<min){
                min = distance[i];
                node = i;
            }
        }
        return node;
    }
}
class Node{
    int val;
    int distance;
    public Node(int val, int distance){
        this.val = val;
        this.distance = distance;
    }
}
```

m is the number of edges and n is the number of nodes.

Time: O((m+n)*n) = O(m*n)

Space: O(m+n) = O(m)

### heap solution

Traverse `distance` to find the min distance not from S, it takes O(n), to save it, use heap which only take O(logn) for distance.

```

```