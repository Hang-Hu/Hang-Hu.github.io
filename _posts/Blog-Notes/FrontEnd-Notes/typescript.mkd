## Install

```
npm install -g typescript
```

## Start to use

Edits greeter.ts

```
function greeter(person) {
    return "Hello, " + person;
}

let user = "Jane User";

document.body.innerHTML = greeter(user);
```

```
tsc greeter.ts
```

This compiled `greeter.js` is the same as `greeter.ts`.

## Annotation

Compile `greeter.ts`(`: string` annotation)

```
function greeter(person: string) {
    return "Hello, " + person;
}

let user = "Jane User";

document.body.innerHTML = greeter(user);
```

To `greeter.js`

```
function greeter(person) {
    return "Hello, " + person;
}
var user = "Jane User";
document.body.innerHTML = greeter(user);
```

## Argument type not assignable

Compile `greeter.ts`(pass `string[]` to `string`)

```
function greeter(person: string) {
    return `hello ${person}`;
}
let user = ["Jane", "Black"];

document.body.innerHTML = greeter(user);
```

To  `greeter.js`

```
greeter.ts:8:35 - error TS2345: Argument of type 'string[]' is not assignable to parameter of type 'string'.

8 document.body.innerHTML = greeter(user);
```

Notice that although there were errors, the greeter.js file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.

```
function greeter(person) {
    return "hello " + person;
}
var user = ["Jane", "Black"];
document.body.innerHTML = greeter(user);
```

## Interfaces

Let’s develop our sample further. Here we use an interface that describes objects that have a `firstName` and `lastName` field. In TypeScript, two types are compatible if their ***internal structure is compatible***. This allows us to implement an interface just by ***having the shape*** the interface requires, ***without an explicit implements*** clause.

```
interface Person {
    firstName: string;
    lastName: string;
}
function greeter(person: Person) {
    return `hello ${person.firstName} ${person.lastName}`;
}
let user = {firstName: "Jane", lastName: "Black"};

document.body.innerHTML = greeter(user);
```

```
function greeter(person) {
    return "hello " + person.firstName + " " + person.lastName;
}
var user = { firstName: "Jane", lastName: "Black" };
document.body.innerHTML = greeter(user);
```

## Classes

`public` in constructor parameter is to create property with that name, like `this.firstName = firstName`.

```
window.addEventListener("load", init);

interface Person {
    firstName: string;
    lastName: string;
}
class Student {
    fullName: string;
    constructor(public firstName: string, public middleInitial: string, public lastName: string){
        this.fullName = `${firstName} ${middleInitial} ${lastName}`;
    }
}
function greeter(person: Person) {
    return `hello ${person.firstName} ${person.lastName}`;
}
let user = new Student("Jane", "M", "User");

function init(){
    document.body.innerHTML = greeter(user);
}
```

```
window.addEventListener("load", init);
var Student = /** @class */ (function () {
    function Student(firstName, middleInitial, lastName) {
        this.firstName = firstName;
        this.middleInitial = middleInitial;
        this.lastName = lastName;
        this.fullName = firstName + " " + middleInitial + " " + lastName;
    }
    return Student;
}());
function greeter(person) {
    return "hello " + person.firstName + " " + person.lastName;
}
var user = new Student("Jane", "M", "User");
function init() {
    document.body.innerHTML = greeter(user);
}
```

## Typescript with react and webpack

```
proj/
├─ dist/
└─ src/
   └─ components/
```

```
mkdir src
mkdir src/components
```

dist will be generated by webpack.

```
npm init
npm install -g webpack webpack-cli
```

Let’s now add React and React-DOM, along with their declaration files, as dependencies to your package.json file:

```
npm install --save react react-dom @types/react @types/react-dom
```

That `@types/` prefix means that we also want to get the ***declaration files*** for `React` and `React-DOM`. Usually when you import a path like "react", it will look inside of the react package itself; however, not all packages include declaration files, so TypeScript also looks in the `@types/react` package as well. You’ll see that we won’t even have to think about this later on.

Next, we’ll add development-time dependencies on awesome-typescript-loader and source-map-loader.

```
npm install --save-dev typescript awesome-typescript-loader source-map-loader
```

awesome-typescript-loader helps Webpack compile your TypeScript code using the TypeScript’s standard configuration file named tsconfig.json. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating its own sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.

awesome-typescript-loader is not the only loader for typescript. You could instead use ts-loader.

```
touch proj/tsconfig.json
```

```
{
    "compilerOptions": {
        "outDir": "./dist/",
        "sourceMap": true,
        "noImplicitAny": true,
        "module": "commonjs",
        "target": "es5",
        "jsx": "react"
    },
    "include": [
        "./src/**/*"
    ]
}
```

```
touch proj/src/components/Hello.tsx
```

```
import * as React from 'react';

export interface HelloProps {
    compiler: string;
    framework: string;
}

export const Hello = (props: HelloProps) => <h1>Hello from {props.compiler} and {props.framework}</h1>;
```

This is stateless functional components, below is a classier one.

```
import * as React from "react";

export interface HelloProps { compiler: string; framework: string; }

// 'HelloProps' describes the shape of props.
// State is never set so we use the '{}' type.
export class Hello extends React.Component<HelloProps, {}> {
    render() {
        return <h1>Hello from {this.props.compiler} and {this.props.framework}!</h1>;
    }
}
```

```
touch proj/src/index.tsx
```

```
import * as React from 'react';
import * as ReactDOM from 'react-dom';

import { Hello } from './components/Hello';

window.addEventListener("load", init);

function init() {
    ReactDOM.render(
        <Hello compiler="Typescript" framework="React" />,
        document.querySelector("#example")
    );
}
```

We just imported our `Hello` component into `index.tsx`. Notice that unlike with `react` or `react-dom`, we used a relative path to `Hello.tsx` - this is important. If we hadn’t, TypeScript would’ve instead tried looking in our `node_modules` folder.

```
touch proj/index.html
```

```
<html>
    <head>
        <meta charset="UTF-8">
        <title>Hello React and Typescript</title>
        <script src="./node_modules/react/umd/react.development.js"></script>
        <script src="./node_modules/react-dom/umd/react-dom.development.js"></script>
        <script src="./dist/bundle.js"></script>
    </head>
    <body>
        <div id="example"></div>
    </body>
</html>
```

Notice that we’re including files from within node_modules. React and React-DOM’s npm packages include standalone .js files that you can include in a web page, and we’re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN).

### webpack configuration file

```
touch proj/webpack.config.js
```

```
module.exports = {
    entry: "./src/index.tsx",
    output: {
        filename: "bundle.js",
        path: __dirname + "/dist"
    },

    // Enable sourcemaps for debugging webpack's output.
    devtool: "source-map",

    resolve: {
        // Add '.ts' and '.tsx' as resolvable extensions.
        extensions: [".ts", ".tsx", ".js", ".json"]
    },

    module: {
        rules: [
            // All files with a '.ts' or '.tsx' extension will be handled by 'awesome-typescript-loader'.
            { test: /\.tsx?$/, loader: "awesome-typescript-loader" },

            // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
            { enforce: "pre", test: /\.js$/, loader: "source-map-loader" }
        ]
    },

    // When importing a module whose path matches one of the following, just
    // assume a corresponding global variable exists and use that instead.
    // This is important because it allows us to avoid bundling all of our
    // dependencies, which allows browsers to cache those libraries between builds.
    externals: {
        "react": "React",
        "react-dom": "ReactDOM"
    }
};
```

You might be wondering about that externals field. We want to avoid bundling all of React into the same file, since this increases compilation time and browsers will typically be able to cache a library if it doesn’t change.

Ideally, we’d just import the React module from within the browser, but most browsers still don’t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like `jQuery` or `_`. This is called the “namespace pattern”, and webpack allows us to continue leveraging libraries written that way. With our entry for "react": "React", webpack will work its magic to make any import of "react" load from the `React` variable.

### Run webpack

```
webpack
```



